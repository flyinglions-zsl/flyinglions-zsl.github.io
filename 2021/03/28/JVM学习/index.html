<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>JVM学习 | Zhousl&#39;s Blog | 做她的英雄</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="JVM">
    <meta name="description" content="JVM类加载JVM整体的加载过程声明周期： JVM伴随Java程序的开始而开始，程序的结束而停止。一个Java程序会开启一个JVM进程，一台计算机上可以运行多个程序，也就可以运行多个JVM进程。 JVM将线程分为两种：守护线程和普通线程。守护线程是JVM自己使用的线程，比如垃圾回收（GC）就是一个守护线程。普通线程一般是Java程序的线程，只要JVM中有普通线程在执行，那么JVM就不会停止。 启动">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习">
<meta property="og:url" content="https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Zhousl&#39;s Blog">
<meta property="og:description" content="JVM类加载JVM整体的加载过程声明周期： JVM伴随Java程序的开始而开始，程序的结束而停止。一个Java程序会开启一个JVM进程，一台计算机上可以运行多个程序，也就可以运行多个JVM进程。 JVM将线程分为两种：守护线程和普通线程。守护线程是JVM自己使用的线程，比如垃圾回收（GC）就是一个守护线程。普通线程一般是Java程序的线程，只要JVM中有普通线程在执行，那么JVM就不会停止。 启动">
<meta property="og:image" content="https://github.com/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/JVM%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617460058137-9799f525-5b37-4498-947c-c2080670edcf.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1616850631833-55a377a7-b126-40a1-a447-02cec032970e.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1616938423035-31c89842-622b-48db-a80a-20c763c35da5.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617201607561-5faaec31-3353-4ed4-9c6e-5df99c95ae7e.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617203787171-c03c0e63-0f00-4afc-bdeb-9c7cd7408ab5.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617204051112-2efad6e6-54b5-4376-ad5e-7bebf807b85c.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617203827373-5158c452-ea47-405b-b62d-e4090f98a6c4.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617204170110-790f84ca-85f2-4e2c-bd35-07841e87b88a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617204681301-ed1af7be-6487-445a-b0ee-271077c47d4f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617499842167-f422f185-98b9-4655-873e-c3740aa9331b.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/jpeg/705191/1618323519375-4fba8feb-6f5a-4522-bab1-6e1947a1ae25.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617761637319-ed84cc95-32cc-4fb1-88fc-586efc23222b.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617764446559-8103c54a-1e23-4547-a1e4-09dd12c3916c.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617764987257-a0494da5-c83c-4092-b0b3-9e4635206088.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617776742667-43bdf030-6f55-4d31-917b-2351afc45884.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617776860916-57982473-5348-4a77-a956-e02d2d836f0a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617779390080-711e6daa-1ace-47c6-a047-c46e389b92ad.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/jpeg/705191/1618323519502-c4b0f3af-2faa-452b-8288-5add52720d2a.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1617876354993-d468469f-be00-47fb-875c-1243dca5a25d.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618585640205-90fc287c-78b1-421f-aea1-e26fce4618d2.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618585655862-ec2a60f7-0682-489c-ba84-8fabb994dbd9.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618586701469-a04cd7c8-ae65-4eef-81bc-a5b6575593cf.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618586749624-2d752b7e-e519-4652-8e26-ae07d4d2235f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618624988169-70edd65b-ee72-46f7-b3d3-b5f694f3fde6.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618625050340-f97c4be5-454a-4f86-bb91-6c528c7235ee.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618627307192-d8bdd439-baab-4226-b948-0cbfb82ee031.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618635052800-2ccf3c53-e825-45d1-9025-693b5bd2eb57.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618635237451-8b1e0ea9-0650-4099-a5bd-11a4df1a6b9f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618636773174-beb16e4e-3401-4874-be0c-f37c4524d98a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1618728113747-42b8e99d-4c42-496b-94d0-222b3ecca799.png?x-oss-process=image%252Fresize%252Cw_1500">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1619101930292-3e6146ce-8b0a-45a9-9287-5fe6ccc86e71.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1619447796774-ecb4e7fb-a3c3-463a-b24a-37b7ca0bddc3.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/705191/1620393652919-436b2c76-ae28-4618-a792-d307cadd4af6.png?x-oss-process=image%252Fresize%252Cw_1500">
<meta property="article:published_time" content="2021-03-28T14:59:18.000Z">
<meta property="article:modified_time" content="2021-06-09T14:54:14.021Z">
<meta property="article:author" content="flyinglions-zsl">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/JVM%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/head.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/logo.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">flyinglions-zsl</h5>
          <a href="mailto:709246423@qq.com" title="709246423@qq.com" class="mail">709246423@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives/"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/"  >
                <i class="icon icon-lg icon-th-list"></i>
                目录
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/flyinglions-zsl" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.cnblogs.com/flyinglion/" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-link"></i>
                博客园
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JVM学习</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JVM学习</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-03-28T14:59:18.000Z" itemprop="datePublished" class="page-time">
  2021-03-28
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/JVM/">JVM</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JVM类加载"><span class="post-toc-number">1.</span> <span class="post-toc-text">JVM类加载</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JVM整体的加载过程"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">JVM整体的加载过程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#loadClass的类加载过程"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">loadClass的类加载过程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#类加载器"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">类加载器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#双亲委派机制"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">双亲委派机制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#全盘委托机制"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">全盘委托机制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#自定义类加载器"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">自定义类加载器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#打破双亲委派机制"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">打破双亲委派机制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Tomcat如何实现打破双亲委派机制"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">Tomcat如何实现打破双亲委派机制</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JVM内存模型"><span class="post-toc-number">2.</span> <span class="post-toc-text">JVM内存模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#概念图"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">概念图</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字节码解析"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">字节码解析</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#栈"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">栈</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Java虚拟机栈"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">Java虚拟机栈</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#本地方法栈"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">本地方法栈</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#程序计数器"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">程序计数器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#堆"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">堆</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#方法区"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">方法区</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JVM内存参数设置"><span class="post-toc-number">3.</span> <span class="post-toc-text">JVM内存参数设置</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#堆-1"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">堆</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#方法区-1"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">方法区</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#栈-1"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">栈</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JVM对象创建与内存分配机制"><span class="post-toc-number">4.</span> <span class="post-toc-text">JVM对象创建与内存分配机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对象创建"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">对象创建</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1类加载检查"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">1类加载检查</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2分配内存"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">2分配内存</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3初始化零值"><span class="post-toc-number">4.1.3.</span> <span class="post-toc-text">3初始化零值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4设置对象头"><span class="post-toc-number">4.1.4.</span> <span class="post-toc-text">4设置对象头</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5执行init方法"><span class="post-toc-number">4.1.5.</span> <span class="post-toc-text">5执行init方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针压缩和对象大小"><span class="post-toc-number">4.1.6.</span> <span class="post-toc-text">指针压缩和对象大小</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对象内存分配"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">对象内存分配</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1在栈上面为对象分配内存"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">1在栈上面为对象分配内存</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2在堆上面为对象分配内存"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">2在堆上面为对象分配内存</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1Eden区分配"><span class="post-toc-number">4.2.2.1.</span> <span class="post-toc-text">2.1Eden区分配</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2大对象直接进入老年代"><span class="post-toc-number">4.2.2.2.</span> <span class="post-toc-text">2.2大对象直接进入老年代</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3长期存活的对象将进入老年代"><span class="post-toc-number">4.2.2.3.</span> <span class="post-toc-text">2.3长期存活的对象将进入老年代</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4对象动态年龄判断"><span class="post-toc-number">4.2.2.4.</span> <span class="post-toc-text">2.4对象动态年龄判断</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-5老年代空间分配担保机制"><span class="post-toc-number">4.2.2.5.</span> <span class="post-toc-text">2.5老年代空间分配担保机制</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对象内存回收"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">对象内存回收</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一般回收方法"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">一般回收方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常用引用类型"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">常用引用类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最后的救赎-判断是否存活"><span class="post-toc-number">4.3.3.</span> <span class="post-toc-text">最后的救赎(判断是否存活)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何判断一个类是无用的类"><span class="post-toc-number">4.3.4.</span> <span class="post-toc-text">如何判断一个类是无用的类</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JVM字节码文件结构剖析"><span class="post-toc-number">5.</span> <span class="post-toc-text">JVM字节码文件结构剖析</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JVM垃圾收集器"><span class="post-toc-number">6.</span> <span class="post-toc-text">JVM垃圾收集器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#基本回收算法"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">基本回收算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#标记-清除算法"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">标记-清除算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#标记-复制算法"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">标记-复制算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#标记-整理算法"><span class="post-toc-number">6.1.3.</span> <span class="post-toc-text">标记-整理算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#分代收集算法"><span class="post-toc-number">6.1.4.</span> <span class="post-toc-text">分代收集算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HotSpot算法实现"><span class="post-toc-number">6.1.5.</span> <span class="post-toc-text">HotSpot算法实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#垃圾收集器种类"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">垃圾收集器种类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Serial收集器"><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">Serial收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Serial-Old收集器"><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">Serial Old收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ParNew收集器"><span class="post-toc-number">6.2.3.</span> <span class="post-toc-text">ParNew收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Parallel-Scavenge收集器"><span class="post-toc-number">6.2.4.</span> <span class="post-toc-text">Parallel Scavenge收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Parallel-Old"><span class="post-toc-number">6.2.5.</span> <span class="post-toc-text">Parallel Old</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CMS收集器"><span class="post-toc-number">6.2.6.</span> <span class="post-toc-text">CMS收集器</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JVM调优工具及了解"><span class="post-toc-number">7.</span> <span class="post-toc-text">JVM调优工具及了解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常见的调优指令"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">常见的调优指令</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jps"><span class="post-toc-number">7.1.1.</span> <span class="post-toc-text">jps</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jmap"><span class="post-toc-number">7.1.2.</span> <span class="post-toc-text">jmap</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内存"><span class="post-toc-number">7.1.2.1.</span> <span class="post-toc-text">内存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#堆-2"><span class="post-toc-number">7.1.2.2.</span> <span class="post-toc-text">堆</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jstack"><span class="post-toc-number">7.1.3.</span> <span class="post-toc-text">jstack</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jinfo"><span class="post-toc-number">7.1.4.</span> <span class="post-toc-text">jinfo</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jstat"><span class="post-toc-number">7.1.5.</span> <span class="post-toc-text">jstat</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jvisualvm"><span class="post-toc-number">7.1.6.</span> <span class="post-toc-text">jvisualvm</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#优化思路"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">优化思路</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-年轻代对象增长的速率"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">1.年轻代对象增长的速率</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-young-gc触发的频率和单次耗时时间"><span class="post-toc-number">7.2.2.</span> <span class="post-toc-text">2.young gc触发的频率和单次耗时时间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-每次young-gc后有多少对象是存活的且进入老年代"><span class="post-toc-number">7.2.3.</span> <span class="post-toc-text">3.每次young gc后有多少对象是存活的且进入老年代</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-Full-GC的触发频率和单次耗时时间"><span class="post-toc-number">7.2.4.</span> <span class="post-toc-text">4.Full GC的触发频率和单次耗时时间</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#常量池了解"><span class="post-toc-number">8.</span> <span class="post-toc-text">常量池了解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Class常量池（class-constant-pool）"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">Class常量池（class constant pool）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字面量"><span class="post-toc-number">8.1.1.</span> <span class="post-toc-text">字面量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#符号引用"><span class="post-toc-number">8.1.2.</span> <span class="post-toc-text">符号引用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#运行时常量池（runtime-constant-pool）"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">运行时常量池（runtime constant pool）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字符串常量池"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">字符串常量池</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#设计思想"><span class="post-toc-number">8.3.1.</span> <span class="post-toc-text">设计思想</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三种字符串操作"><span class="post-toc-number">8.3.2.</span> <span class="post-toc-text">三种字符串操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串常量池位置"><span class="post-toc-number">8.3.3.</span> <span class="post-toc-text">字符串常量池位置</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#设计原理"><span class="post-toc-number">8.3.4.</span> <span class="post-toc-text">设计原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常见字符串比较问题"><span class="post-toc-number">8.3.5.</span> <span class="post-toc-text">常见字符串比较问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#八大基本类型和对象池"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">八大基本类型和对象池</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-JVM学习"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JVM学习</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-03-28 22:59:18" datetime="2021-03-28T14:59:18.000Z"  itemprop="datePublished">2021-03-28</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/JVM/">JVM</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="JVM类加载"><a href="#JVM类加载" class="headerlink" title="JVM类加载"></a>JVM类加载</h1><h2 id="JVM整体的加载过程"><a href="#JVM整体的加载过程" class="headerlink" title="JVM整体的加载过程"></a>JVM整体的加载过程</h2><p>声明周期：</p>
<p>JVM伴随Java程序的开始而开始，程序的结束而停止。一个Java程序会开启一个JVM进程，一台计算机上可以运行多个程序，也就可以运行多个JVM进程。</p>
<p>JVM将线程分为两种：守护线程和普通线程。守护线程是JVM自己使用的线程，比如垃圾回收（GC）就是一个守护线程。普通线程一般是Java程序的线程，只要JVM中有普通线程在执行，那么JVM就不会停止。</p>
<p>启动大概过程：</p>
<img src="/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/JVM%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png" class="">

<p>launcher是一个static且new初始化的变量(即单例)</p>
<p>lancher构造方法会初始化ext类加载器、再由得到的ext类加载器去加载app类加载器。</p>
<p>（app类加载器父类是ext类加载器，ext类加载器原则上是引导类加载器，但引导类是c++创建的，所以其父类加载器为null）  </p>
<p>classLoader-&gt;即app类加载器，launcher源码体现。</p>
<p>ClassLoader:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617460058137-9799f525-5b37-4498-947c-c2080670edcf.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<h2 id="loadClass的类加载过程"><a href="#loadClass的类加载过程" class="headerlink" title="loadClass的类加载过程"></a>loadClass的类加载过程</h2><p><strong>加载(load)&gt;&gt;链接(link)(验证**</strong>&gt;&gt;准备<strong><strong>&gt;&gt;解析)</strong></strong>&gt;&gt;初始化<strong><strong>(initialize)</strong></strong>&gt;&gt;使用<strong>**&gt;</strong>&gt;卸载</p>
<ul>
<li><p>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的Main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
</li>
<li><p>验证：校验字节码文件的正确性(语义合法、符合逻辑)、文件格式验证(需要符合class文件格式)、元数据验证、符号引用验证(确保解析能够正确执行)等。</p>
</li>
<li><p>准备：给类的<strong>静态变量</strong>分配内存，并赋予默认值(如：int的给0，boolean的给false)，final变量直接赋值。这个时候不包括实例变量，实例变量会在对象实例化的时候随着对象一块分配在Java堆中。</p>
</li>
<li><p>解析：将符号引用替换为直接引用(内存地址)，该阶段会把一些静态方法（符号引用，比如main()方法）替换为指向数据所存<strong>内存的指针或句柄</strong>等(直接引用)，这就是所谓的<strong>静态链接</strong>过程。<strong>动态链接</strong>是在程序运行期间完成的将符号引用替换为直接引用（每个类名、方法、包路径等都是一个符号 存在于常量池中，运行时加载到运行时常量池中javap xx.class -v 查看）。</p>
</li>
<li><p>初始化：对类的静态变量初始化为指定的值，执行静态代码块。 </p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1616850631833-55a377a7-b126-40a1-a447-02cec032970e.png" alt="img"></p>
<p>类被加载到方法区中后主要包含 <strong>运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例</strong>的引用等信息。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul>
<li><p>引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等</p>
</li>
<li><p>扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包</p>
</li>
<li><p>应用程序类加载器：负责加载CLassPath路径下(项目路径)的类包，主要就是加载自己写的类</p>
</li>
<li><p>自定义加载器：负责加载用户自定义路径下的类包</p>
</li>
</ul>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1616938423035-31c89842-622b-48db-a80a-20c763c35da5.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>说明：JVM定义从应用程序类加载器开始加载(具体可看launcher源码 方法getClassLoader())，加载某个类时会委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器都无法在自己的加载类路径下找到目标类，则向下查找并载入目标类。</p>
<p>比如User类，先找到app类加载器加载，app类加载器先委托ext加载器加载，ext加载器再委托引导类加载器加载，引导类加载器在其类加载路径中找不到User类，则向下退回加载User类的请求，ext收到回复就自己加载，ext在其类加载路径中找不到User类，又向下退回给app类加载器，app类加载器则在自己的类加载路径里找User类，找到了则自己加载。95%以上都是app类加载器应用。(源码-&gt;appClassLoader的loadClass，跳到super的ClassLoader 的loadClas方法，重点-&gt;UrlClassLoader的findCass(name)，装载类即 defineClass() 去类路径拿到class文件)</p>
<p>为什么要设计双亲委派机制？</p>
<ul>
<li>沙箱安全机制：自己的java.lang.String.class类不会被加载，防止核心API库被篡改。</li>
</ul>
<p>根据双亲委派机制，先会向上加载一次，String类是引导类加载器加载的，这时候引导类加载器找到的是JDK自己的String类且返回(只会加载自己定义的类)，再向下回到app类中，这时候调用则会报错。</p>
<ul>
<li>避免类的重复加载：向上委托，如果父加载器已经加载过了某个类，则会直接返回，子ClassLoader就不会再次加载一次，保证被加载类的唯一性。</li>
</ul>
<h2 id="全盘委托机制"><a href="#全盘委托机制" class="headerlink" title="全盘委托机制"></a>全盘委托机制</h2><p>全盘负责 指的是，当一个ClassLoader加载一个类时，除非显示的使用另外一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入。（如User类里用到了 Menu类，这时Menu的加载也是由User 的App类加载器加载）</p>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>初始化自定义类加载器，会先初始化父类加载器（默认是app类加载器），其中把自定义类加载器的父类设定为app类加载器，符合双亲委派机制。</p>
<p>1继承ClassLoader</p>
<p>2重写findClass方法</p>
<p>核心就是UrlClassLoader的loadClass()方法(实现双亲委派机制)和findClass()方法(装载类)。</p>
<h2 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h2><p>不委托父加载器先加载了，在自定义加载器获得了直接返回。</p>
<p>重写loadClass方法   去掉双亲委派的逻辑</p>
<h2 id="Tomcat如何实现打破双亲委派机制"><a href="#Tomcat如何实现打破双亲委派机制" class="headerlink" title="Tomcat如何实现打破双亲委派机制"></a>Tomcat如何实现打破双亲委派机制</h2><p>基于自定义的类加载器，是自定义类型的时，不委托父加载器加载。</p>
<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p>不同的机器对应的JVM处理机器码的方式都不同，如windows、mac系统</p>
<p>javap -c xx.class看汇编c</p>
<h2 id="概念图"><a href="#概念图" class="headerlink" title="概念图"></a>概念图</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617201607561-5faaec31-3353-4ed4-9c6e-5df99c95ae7e.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>栈帧：一个方法对应一块栈帧区域，基本就是数据结构中的栈，特性先进后出，后进先出，符合代码执行特性。</p>
<p>操作数栈：临时的内存空间</p>
<p>验证代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.gx.demo.jvm;</span><br><span class="line"></span><br><span class="line">public class MyMath &#123;</span><br><span class="line"></span><br><span class="line">    public int calculate(int a, int b)&#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        result &#x3D; (a + b)*5;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyMath myMath &#x3D; new MyMath();</span><br><span class="line">        int res &#x3D; myMath.calculate(3, 7);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="字节码解析"><a href="#字节码解析" class="headerlink" title="字节码解析"></a>字节码解析</h2><p>javap -c MyMath.class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public com.gx.demo.jvm.MyMath();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom&#x2F;gx&#x2F;demo&#x2F;jvm&#x2F;MyMath;</span><br><span class="line"></span><br><span class="line">  public int calculate(int, int);</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:&#x2F;&#x2F;一个方法对应一个栈帧，即有自己的局部变量表</span><br><span class="line">      stack&#x3D;2, locals&#x3D;4, args_size&#x3D;3&#x2F;&#x2F;a-&gt;局部变量1 b-&gt;局部变量2</span><br><span class="line">         0: iconst_0&#x2F;&#x2F;将int类型常量0压入栈 常量0</span><br><span class="line">         1: istore_3&#x2F;&#x2F; 将int类型值存入局部变量3 参数result</span><br><span class="line">         2: iload_1&#x2F;&#x2F;从局部变量1中装载int类型值 参数a</span><br><span class="line">         3: iload_2&#x2F;&#x2F;从局部变量2中装载int类型值 参数b</span><br><span class="line">         4: iadd&#x2F;&#x2F;执行int类型的加法</span><br><span class="line">         5: iconst_5&#x2F;&#x2F;将int类型常量5压入栈 得到a+b&#x3D;5</span><br><span class="line">         6: imul&#x2F;&#x2F;乘法</span><br><span class="line">         7: istore_3&#x2F;&#x2F; 将int类型值存入局部变量3 即5*10&#x3D;50</span><br><span class="line">         8: iload_3&#x2F;&#x2F;从局部变量2中装载int类型值 50</span><br><span class="line">         9: ireturn&#x2F;&#x2F;返回</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 2</span><br><span class="line">        line 8: 8</span><br><span class="line">      LocalVariableTable:&#x2F;&#x2F;局部变量</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      10     0  this   Lcom&#x2F;gx&#x2F;demo&#x2F;jvm&#x2F;MyMath;</span><br><span class="line">            0      10     1     a   I</span><br><span class="line">            0      10     2     b   I</span><br><span class="line">            2       8     3 result   I</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">         0: new           #2                  &#x2F;&#x2F; class com&#x2F;gx&#x2F;demo&#x2F;jvm&#x2F;MyMath</span><br><span class="line">         3: dup&#x2F;&#x2F;复制栈顶部一个字长内容</span><br><span class="line">         4: invokespecial #3                  &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1&#x2F;&#x2F;将引用类型或returnAddress类型值存入局部变量1 参数new的myMath，存的堆地址</span><br><span class="line">         8: aload_1&#x2F;&#x2F;从局部变量1中装载引用类型值</span><br><span class="line">         9: iconst_3&#x2F;&#x2F;将int类型常量3压入栈</span><br><span class="line">        10: bipush        7   &#x2F;&#x2F;将一个8位带符号整数压入栈 7 也占一次操作(11)</span><br><span class="line">          &#x2F;&#x2F;iconst_5 &#x3D; 8 (0x8)指令码</span><br><span class="line">          &#x2F;&#x2F;bipush &#x3D; 16 (0x10)指令码</span><br><span class="line">        12: invokevirtual #4  &#x2F;&#x2F;调度对象的方法   &#x2F;&#x2F; Method calculate:(II)I</span><br><span class="line">        15: istore_2&#x2F;&#x2F;将int类型值存入局部变量2 参数res</span><br><span class="line">        16: getstatic     #5                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        19: iload_2&#x2F;&#x2F;从局部变量2中装载int类型值 calculate返回的结果50</span><br><span class="line">        20: invokevirtual #6                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">        23: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 8</span><br><span class="line">        line 14: 16</span><br><span class="line">        line 15: 23</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      24     0  args   [Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">            8      16     1 myMath   Lcom&#x2F;gx&#x2F;demo&#x2F;jvm&#x2F;MyMath;</span><br><span class="line">           16       8     2   res   I</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处涉及一个常量推送到栈顶中，不同范围指令不同：</p>
<p>iconst_*  即-1-5 </p>
<p>bipush    即<strong>-128~127</strong> </p>
<p>sipush    即-32768~32767 </p>
<p>ldc         即<strong>-2147483648~2147483647</strong></p>
<p>具体可见官网：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iconst_i" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iconst_i</a></p>
<p>icons-》push int constant</p>
<p>bipush-》push byte , etc.</p>
<table>
<thead>
<tr>
<th>指令名称</th>
<th>指令码（对应class码文件）</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td><em>iconst_m1</em></td>
<td>2 (0x2)</td>
<td>-1</td>
</tr>
<tr>
<td><em>iconst_0</em></td>
<td>3 (0x3)</td>
<td>0</td>
</tr>
<tr>
<td><em>iconst_1</em></td>
<td>4 (0x4)</td>
<td>1</td>
</tr>
<tr>
<td><em>iconst_2</em></td>
<td>5 (0x5)</td>
<td>2</td>
</tr>
<tr>
<td><em>iconst_3</em></td>
<td>6 (0x6)</td>
<td>3</td>
</tr>
<tr>
<td><em>iconst_4</em></td>
<td>7 (0x7)</td>
<td>4</td>
</tr>
<tr>
<td><em>iconst_5</em></td>
<td>8 (0x8)</td>
<td>5</td>
</tr>
</tbody></table>
<p>简单说下calculate方法 运作情况：</p>
<p>1、局部变量和操作数栈各自对应</p>
<p>–》0: iconst_0，0代表程序计数器的位置，每次操作完都会更新</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617203787171-c03c0e63-0f00-4afc-bdeb-9c7cd7408ab5.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>



<p>2、由字节码执行引擎执行操作数为1的步骤,且更新操作数(由字节码执行引擎修改)</p>
<p>–》1: istore_3 程序计数器=1</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617204051112-2efad6e6-54b5-4376-ad5e-7bebf807b85c.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617203827373-5158c452-ea47-405b-b62d-e4090f98a6c4.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>3a+b操作</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617204170110-790f84ca-85f2-4e2c-bd35-07841e87b88a.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>说明：3、7、5等常量都放在操作数栈，临时内存</p>
<p>动态链接：myMath.calculate()，要去解析 找到对应的方法</p>
<p>局部变量和堆：new  MyMath()</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617204681301-ed1af7be-6487-445a-b0ee-271077c47d4f.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈是线程私有的，就是平常说的堆栈中的“栈内存”。此处指的是JVM中的运行时内存区域的概念划分，而不是JMM(java 内存模型)，每个方法在执行的同时都会创建一个栈帧(Stack Frame)，方法结束，栈内存也就自动释放了。</p>
<p>其中包括四个部分，分别是：</p>
<p>1局部变量表(用来存储局部变量表的，包含两部分：一是方法中的参数，二是方法中创建的局部变量。局部变量必须被初始化才能使用。包括this，FILO)</p>
<p>2操作数栈(方法用到的常量等，FILO)</p>
<p>3动态链接(方法中对象的引用，存的堆地址等)</p>
<p>4方法出口(方法return到哪个地方)等信息</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>JVM 调用本地方法(Native)接口时使用，也是线程私有的(历史原因，之前很多接口由C/C++实现的，字节码解析后调用相应的dll文件)，这时候使用的空间就是本地方法栈。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>在JVM中的运行时内存区域的概念划分中，目前自己了解到主要以下作用，其通过字节码执行引擎工作执行class文件，由字节码执行引擎修改当前这个程序计数器的值来选取下一条需要执行的字节码指令(上面图中有体现)。</p>
<p>(以下为参考)</p>
<p>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。</p>
<p>当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址；如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。</p>
<p>程序计数器占用的内存空间很少，也是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617499842167-f422f185-98b9-4655-873e-c3740aa9331b.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>堆内存是<strong>所有线程共享</strong>的，基本上可以分为<strong>一个年轻代</strong>和<strong>一个老年代</strong>。</p>
<p><strong>1.年轻代</strong>分为两部分：伊甸区（Eden space）和 幸存者区（Survivor space）。所有的类都是在伊甸区被new出来</p>
<p>的。幸存者区又分为 From 区 和 To 区。当Eden区的空间用完时，程序要继续new对象，JVM的垃圾回收器将对</p>
<p>Eden区进行垃圾回收（Minor GC，通过gc root(从栈(局部变量)、方法区中去找变量的引用，一直往前找，找到根时如果没有别人对象引用，则会标志为垃圾对象，否则标志为非垃圾对象)），将Eden区中的不再被其他对象应用的对象销毁，然后将剩余的对象移到From Survivor区。若From区也满了，再对该区进行垃圾回收，然后将剩余的移动到To Survivor区。</p>
<p><strong>2.老年代</strong>：新生代经过多次GC仍然存活的对象移动到老年代。若老年代满了，则会发生Major GC（Full GC）进行老年区的清理。若老年区经理了清理后依然无法进行对象的保存，则会抛出OOM异常以及STW事件。</p>
<p>Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
<p><strong>3.元空间</strong>：在JDK1.8以后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用的本地内存。而永久代在虚拟机中，永久代逻辑结构上也属于堆，但是物理上不属于。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区也是所有线程所共享的。它用于存储已经被JVM加载的类信息(类型信息：差不多是C的对象元信息)、常量(存堆中的地址)、静态变量、即时编译器(JIT)编译后的代码等数据信息。且设有保护程序，当一个线程正在访问的时候，另一个线程不能同时加载一个类，需要延迟等待。</p>
<p>同时，方法区中的大小是可以改变的，运行时也可以扩展，对象也可进行垃圾回收，不过条件比较苛刻，需要没有任何引用才会进行回收。</p>
<p>JDK8之前是永久代，之后叫元空间。</p>
<h1 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h1><h2 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h2><p>常用：</p>
<p>-Xms：JVM初始分配的内存由-Xms指定，默认是物理内存的1/64</p>
<p> -Xmx：JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4</p>
<p>新生代： </p>
<p>-Xmn</p>
<p>-Xmn2G：设置年轻代大小为2G。</p>
<h2 id="方法区-1"><a href="#方法区-1" class="headerlink" title="方法区"></a>方法区</h2><p>-XX:MetaspaceSize 默认21MB(64位JVM)，达到该值则会进行full gc进行类型加载，同时收集器对值进行调整。</p>
<p>-XX:MaxMetaspaceSize 默认无限(64位JVM)，即只限制于本地内存大小</p>
<h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><p>-Xss 默认1M，该值设置的越小，说明一个线程栈里面能分配的栈帧就越少，但是对JVM整体来说能开启的线程数就越多。</p>
<h1 id="JVM对象创建与内存分配机制"><a href="#JVM对象创建与内存分配机制" class="headerlink" title="JVM对象创建与内存分配机制"></a>JVM对象创建与内存分配机制</h1><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>大概流程：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/jpeg/705191/1618323519375-4fba8feb-6f5a-4522-bab1-6e1947a1ae25.jpeg" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<h3 id="1类加载检查"><a href="#1类加载检查" class="headerlink" title="1类加载检查"></a>1类加载检查</h3><p>虚拟机遇到一个new命令时(new指令在语言层次上，代表new关键字，对象的克隆或者序列化等)，</p>
<p>首先将要检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过(即类加载那五个步骤)。如果没有就必须先执行类加载过程。</p>
<p>那什么情况下需要去加载类呢？</p>
<p>1、当创建对象和使用到静态变量的时候，即遇到new、getstatic、putstatic或者invokestatic指令的时候(读取或者设置一个静态变量，finnal修饰和已加载的静态字段除外)。</p>
<p>下图是上面字节码解析中涉及到的一个static变量：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617761637319-ed84cc95-32cc-4fb1-88fc-586efc23222b.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>2、当一个类被初始化时，如果其有父类，且没被初始化过，那会先触发父类的初始化。</p>
<p>3、当使用java.lang.reflect(即反射)时，如果对象没被初始化，则会先进行初始化。</p>
<p>4、当JVM启动时，会先执行一个指定的方法(public main())，这个类会被先初始化。</p>
<h3 id="2分配内存"><a href="#2分配内存" class="headerlink" title="2分配内存"></a>2分配内存</h3><p>在类加载成功后，虚拟机就需要为新生对象分配内存了。</p>
<p>Java的堆内存是被所有线程所共享的一块内存区域，其主要用于存放对象的实例(也包括数组实例)，为实例对象分配内存就是指在堆内存中分配一块大小确定的内存<strong>划分出来</strong>，并给到对象。</p>
<p>其实现主要通过两个方法：</p>
<p>1.指针碰撞法</p>
<p>假设JAVA堆中的内存是绝对规整的，所有用过的内存都放在一侧，空闲的内存放在另一侧，中间通过一个指针作为分界点，<strong>当需要分配内存时，仅仅需要将那个指针往空闲侧移动与对象大小相等的距离即可</strong>。</p>
<p>使用的GC收集器：Serial、ParNew，适用堆内存规整（即没有内存碎片）的情况下。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617764446559-8103c54a-1e23-4547-a1e4-09dd12c3916c.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>(蓝色代表已分配内存空间，白色代表没分配的内存空间)</p>
<p><strong>在最后一块已分配内存后有一个指针连接空闲内存区域。</strong></p>
<p>2.空闲列表法</p>
<p>假设JAVA堆中的内存不是规整的，已经使用过的内存空间是相互交错的，那此时就不能使用指针碰撞来进行内存分配了。<strong>JVM通过维护一个列表，来记录可用的内存信息，在分配的时候从列表中找到一块足够大的空间来划分给对象实例，并更新列表上的记录</strong>。</p>
<p>使用的GC收集器：CMS，适用堆内存不规整的情况下。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617764987257-a0494da5-c83c-4092-b0b3-9e4635206088.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>(蓝色代表已分配内存空间，白色代表没分配的内存空间)</p>
<p>问题：划分内存不管是指针碰撞法，抑或是空闲列表法，当一个线程开始准备占用内存时，另一个线程也可能在抢占内存，这时候即会引起一个熟知的问题–&gt;并发？</p>
<p>解决：如何解决并发来保证线程安全，一般是两种方法</p>
<p>1.CAS(compare and swap)比较替换</p>
<p>CAS是<strong>乐观锁</strong>的一种实现方式。即每次不去加锁，而是假设不会发生冲突的来完成某个操作，如果发生冲突失败就重试，直到操作成功为止。JVM采用CAS配上失败重试的方式保证更新操作的原子性，来对分配内存的动作进行同步处理。</p>
<p>2.TLAB(Thread Local Allocation Buffer) 本地线程分配缓冲</p>
<p><strong>按照线程**</strong>在不同的空间之中进行内存的划分操作<strong>。即给每一个线程在Java堆内存中预先划分、分配一小块内存。也就是说首先在TLAB中配内存，当对象实例需要的内存</strong>大于TLAB的剩余内存<strong>，或者</strong>TLAB中的内存消耗殆尽**的时候，使用CAS机制进行内存的分配。</p>
<p>参数设置：-XX:+UseTLAB（JVM默认开启），关闭-XX:-UseTLAB</p>
<h3 id="3初始化零值"><a href="#3初始化零值" class="headerlink" title="3初始化零值"></a>3初始化零值</h3><p>在分配内存后， JVM需要将分配到的内存空间都初始化为零值(不包括对象头)，如果使用TLAB，这一过程也可以提前至TLAB分配内存时安进行。这一步操作保证了对象的实例字段在Java代码中可以步赋初始值就能直接使用，程序能够访问到这些字段的数据类型所对应的零值(如int的0，boolean的false)。</p>
<h3 id="4设置对象头"><a href="#4设置对象头" class="headerlink" title="4设置对象头"></a>4设置对象头</h3><p>在初始化零值后，JVM需要对对象进行必要的设置，比如：某一个对象属于哪个类的实例，如何才能够找到该类的元数据信息，该对象的hash码、GC分代年龄等信息。以上这些信息基本存在与对象头(Object Header)之中。</p>
<p>（锁相关：<strong>Java对象头和monitor是实现synchronized的基础</strong>）</p>
<p>在HotSpot，对象在内存中存储的布局可以分为3个区域：</p>
<p>1对象头（Header）</p>
<p>2实例数据（Instance Date）</p>
<p>3对齐填充（Padding）</p>
<p><strong>对象头</strong>由Mark Word(标记字段)和Kclass pointer(类型指针)组成。</p>
<p>Mark Word：(32位占4字节，64位占8字节)用于存储对象自身的运行时数据，如哈希码(Hash Code)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。(<strong>对象和数组稍有差别，数组长度占4字节</strong>)。</p>
<p>Kclass pointer：(开启指针压缩占4字节，不开启占8字节)指对象指向它的类元数据的指针，JVM通过这个指针来确定这个对象是哪个类的实例。</p>
<p>下图是内存布局大概分布：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617776742667-43bdf030-6f55-4d31-917b-2351afc45884.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>下图是32位虚拟机对象头各锁对应的信息；</p>
<p>对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit）），它是实现轻量级锁和</p>
<p>偏向锁的关键。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617776860916-57982473-5348-4a77-a956-e02d2d836f0a.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>下图是结合栈以及方法区画了一个个人理解和参考的图</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617779390080-711e6daa-1ace-47c6-a047-c46e389b92ad.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="5执行init方法"><a href="#5执行init方法" class="headerlink" title="5执行init方法"></a>5执行init方法</h3><p>执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值(注意，这与上面的赋零值不同，这是由程序员赋的值)，和执行构造方法。</p>
<h3 id="指针压缩和对象大小"><a href="#指针压缩和对象大小" class="headerlink" title="指针压缩和对象大小"></a>指针压缩和对象大小</h3><p>启用指针压缩:­XX:+UseCompressedOops(默认开启)，禁止指针压缩:­XX:­-UseCompressedOops</p>
<p>大概理解：</p>
<p>在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力。</p>
<p>为了减少64位平台下内存的消耗，启用指针压缩功能。                                                    </p>
<p>​                                                                                                                                                                                </p>
<h2 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/jpeg/705191/1618323519502-c4b0f3af-2faa-452b-8288-5add52720d2a.jpeg" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<h3 id="1在栈上面为对象分配内存"><a href="#1在栈上面为对象分配内存" class="headerlink" title="1在栈上面为对象分配内存"></a>1在栈上面为对象分配内存</h3><p>在Java中，对象的实例几乎都在堆上分配内存，<strong>当对象没有被引用的时候</strong>，需要依赖GC进行垃圾回收，释放内存。如果对象实例过多，会给GC带来巨大的压力，也会影响应用程序的性能。</p>
<p>为了减少<strong>临时对象</strong>在堆内分配的数量，JVM通过逃逸分析确定该对象<strong>不会被外部访问</strong>。如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的内存空间就可以<strong>随栈帧出栈而销毁</strong>，就减轻了垃圾回收的压力。 </p>
<p>对象逃逸分析：就是分析<strong>对象动态作用域</strong>，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中(此时则需要分配堆内存)。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public MyMath getMath()&#123;</span><br><span class="line">    MyMath res &#x3D; new MyMath();</span><br><span class="line">    &#x2F;&#x2F;xxx</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getMath2()&#123;</span><br><span class="line">    MyMath res &#x3D; new MyMath();</span><br><span class="line">    &#x2F;&#x2F;xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像getMath方法，很显然其需要返回一个对象，可能是被另一个调用方使用或者返回等，因此它的作用域不确定。</p>
<p>但getMath2方法，当方法一结束，res对象即无效了，因此对于这种对象，可以将其放在栈中，让它与方法一起结束，跟随栈内存一起被回收。</p>
<p>开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过<strong>标量替换</strong>优先分配在栈上(栈上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis) </p>
<p><strong>(在**</strong>栈上面分配内存依赖于逃逸分析和标量替换，需要同时开启**)</p>
<p><strong>标量替换</strong>：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该 对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就 不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。 </p>
<p><strong>标量与聚合量</strong>：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及 reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</p>
<h3 id="2在堆上面为对象分配内存"><a href="#2在堆上面为对象分配内存" class="headerlink" title="2在堆上面为对象分配内存"></a>2在堆上面为对象分配内存</h3><p>上面介绍堆时已提到过，堆上分配内存大概情况：</p>
<p>所有的类都是在伊甸区被new出来的。幸存者区又分为 From 区 和 To 区。当Eden区的空间用完时，程序要继续new对象，JVM的垃圾回收器将对Eden区进行垃圾回收（Minor GC），将Eden区中的不再被其他对象应用的对象销毁，然后将剩余存活的对象移到From Survivor区。若From区也满了，再对该去、区进行垃圾回收，然后将剩余的移动到To Survivor区。最终再继续存活下来的将存放到老年代。</p>
<h4 id="2-1Eden区分配"><a href="#2-1Eden区分配" class="headerlink" title="2.1Eden区分配"></a>2.1Eden区分配</h4><p><strong>Eden与Survivor区默认8:1:1</strong></p>
<p><strong>-XX:+SurvivorRatio 设置新生代内存的占比</strong></p>
<p>堆新生代：包括Eden区域和Survivor区域(<strong>默认是8</strong>)</p>
<p>参数假设配置N，配置N表示伊甸园区Eden大小即是幸存区from的N倍，也是幸存区to的N倍。</p>
<p>eden:s0:s1=N:1:1</p>
<p>Xmn/(N+1+1) 就是每一份的大小，对应乘就是Eden，s0,s1的大小</p>
<p>即Eden=N<em>(Xmn/(N+2))，survivor(from)=suvivor(to)=1</em>(Xmn/(N+2))</p>
<p>因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，<strong>让eden区尽量的大，survivor区够用即可，</strong> </p>
<p>JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy </p>
<p><strong>两种情况的GC：</strong></p>
<ul>
<li><strong>Minor GC/Young GC</strong>：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。 </li>
<li><strong>Major GC/Full GC</strong>：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。 </li>
</ul>
<p>可通过-XX:+PrintGCDetails进行GC的查看</p>
<h4 id="2-2大对象直接进入老年代"><a href="#2-2大对象直接进入老年代" class="headerlink" title="2.2大对象直接进入老年代"></a>2.2大对象直接进入老年代</h4><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节)</p>
<p>-XX:+UseSerialGC 。</p>
<p>为什么要这样呢？ </p>
<p>为了避免为大对象分配内存时的复制操作而降低效率。</p>
<h4 id="2-3长期存活的对象将进入老年代"><a href="#2-3长期存活的对象将进入老年代" class="headerlink" title="2.3长期存活的对象将进入老年代"></a>2.3长期存活的对象将进入老年代</h4><p>虚拟机给每个对象一个对象年龄（Age）计数器。 </p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 </p>
<h4 id="2-4对象动态年龄判断"><a href="#2-4对象动态年龄判断" class="headerlink" title="2.4对象动态年龄判断"></a>2.4对象动态年龄判断</h4><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的 50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了， 例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发的。 </p>
<h4 id="2-5老年代空间分配担保机制"><a href="#2-5老年代空间分配担保机制" class="headerlink" title="2.5老年代空间分配担保机制"></a>2.5老年代空间分配担保机制</h4><p>在发生Minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p>
<p>1如果大于，则此次Minor GC是安全的，直接进行Minor GC即可。</p>
<p>2如果小于，则会检查-XX:-HandlePromotionFailure</p>
<p>2.1如果没有设置，则会进行Full GC(给老年代和年轻代一起清理一次)</p>
<p>2.2如果有设置，则会判断老年代剩余空间大小是否 <strong>小于</strong> 历史<strong>每一次Minor GC</strong>后进入老年代的对象的<strong>平均大</strong></p>
<p><strong>小</strong>，如果<strong>不小于则发生Minor GC，如果小于，则会发生Full GC(对老年代和年轻代一起发生一次垃圾回收)。</strong></p>
<p>如果回收完还是没有足够空间存放新的对象就会发生”OOM” </p>
<p>当然，<strong>如果**</strong>Minor** <strong>gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full    gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”</strong></p>
<h2 id="对象内存回收"><a href="#对象内存回收" class="headerlink" title="对象内存回收"></a>对象内存回收</h2><h3 id="一般回收方法"><a href="#一般回收方法" class="headerlink" title="一般回收方法"></a>一般回收方法</h3><p>都知道内存回收的是无用对象，但是怎么判断对象是无用还是有用呢？</p>
<p>比较容易想到的是引用计数法。那么什么是引用计数法呢？</p>
<p><strong>引用计数法</strong>：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加１;当引用失效时，计数器值就减１;任何时刻计数器为０的对象就是不可能再使用的。</p>
<p>虽然引用计数算法实现简单且判断效率高效，但是在主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象间相互循环引用的问题。</p>
<p>既然我们学习的是Java虚拟机相关的内容，那我们就要了解Java虚拟机的实现中是怎么判断对象是否存活的？</p>
<p><strong>可达性分析算法</strong>：在主流的商用程序语言的主流实现中，都是称通过可达性分析来判断对象是否存活的。这个算法的基本思路就是通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p>如图所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1617876354993-d468469f-be00-47fb-875c-1243dca5a25d.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>



<p>​            </p>
<h3 id="常用引用类型"><a href="#常用引用类型" class="headerlink" title="常用引用类型"></a>常用引用类型</h3><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>方法区中常量引用的对象</p>
</li>
<li><p>本地方法栈中JNI(即一般说的Native方法)引用的对象</p>
</li>
</ul>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判断对象是否存活都与”引用”有关。</p>
<p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)４种,这4种引用强度依次逐渐减弱。</p>
<p><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似”Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<p><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<p><strong>虚引用</strong>也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
<h3 id="最后的救赎-判断是否存活"><a href="#最后的救赎-判断是否存活" class="headerlink" title="最后的救赎(判断是否存活)"></a>最后的救赎(判断是否存活)</h3><p>对象是怎么被杀死的?</p>
<p>在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历<strong>两次标记</strong>过程——如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象<strong>是否有必要执行finalize()方法</strong>。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。(那么问题来了，这种情况下的二次标记在哪里？)</p>
<p>如果这个对象被判定为<strong>有必要执行</strong>finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的”执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环,将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。<strong>finalize()方法是对象逃脱死亡命运的最后一次机会</strong>，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中成功拯救自己——<strong>只要重新与引用链上的任何一个对象建立关联</strong>即可，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出”即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
<h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢? 类需要同时满足下面3个条件才能算是 “无用的类” :</p>
<ul>
<li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p>
</li>
<li><p>加载该类的 ClassLoader 已经被回收。</p>
</li>
<li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<p>​                                                            </p>
<h1 id="JVM字节码文件结构剖析"><a href="#JVM字节码文件结构剖析" class="headerlink" title="JVM字节码文件结构剖析"></a>JVM字节码文件结构剖析</h1><p>javap -verbose xxx.class 反编译</p>
<p><strong>通过16进制查看器打开的文件结构是一个当个字节来显示，因为一个16进制数可</strong> </p>
<p><strong>以通过4位来表示,一个字节8位可以表示二个16进制数</strong></p>
<p>具体代码见目录 –&gt; 字节码解析</p>
<p>整体结构分为：</p>
<ul>
<li><p>class文件结构</p>
</li>
<li><p>类的访问权限</p>
</li>
<li><p>字段表结构</p>
</li>
<li><p>方法表结构</p>
</li>
<li><p>方法中属性表结构</p>
</li>
</ul>
<h1 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h1><h2 id="基本回收算法"><a href="#基本回收算法" class="headerlink" title="基本回收算法"></a>基本回收算法</h2><p>在堆中几乎保存着所有能够想到的对象实例，也就是根据对象存活的周期不同，将内存分为不同的块。</p>
<p>而目前的JVM中处理垃圾收集的方式–几乎都采用的分代收集算法(<strong>即**</strong>将对象熬过垃圾收集的次数，视为对象的年龄，也依此将对象至少划分为新生代和老年代这两个代**)。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><strong>简介</strong>：最基础的收集算法是“标记-清除”(Mark-Sweep)算法，如其名，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；也可以返回来标记存活的对象，统一回收没有被标记的对象。后续算法都是基于这个优化改进的。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>效率问题：如果需要标记的对象太多，或者清除的对象太多，效率都不高</li>
<li>空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后分配较大对象时，无法找到足够的连续的内存而不得不提前触发另一次垃圾收集操作。</li>
</ul>
<p>回收前：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618585640205-90fc287c-78b1-421f-aea1-e26fce4618d2.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>回收后：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618585655862-ec2a60f7-0682-489c-ba84-8fabb994dbd9.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>简介：为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，运行高效。</p>
<p>缺点：</p>
<ul>
<li>直接将原有内存缩小为了原来的一半，代价太高了。</li>
<li>如果对象存活率较高时就要进行较多的复制操作，效率将会变低。</li>
</ul>
<p>回收前：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618586701469-a04cd7c8-ae65-4eef-81bc-a5b6575593cf.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>回收后：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618586749624-2d752b7e-e519-4652-8e26-ae07d4d2235f.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>



<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法缺点就是<strong>对象存活率较高</strong>时，进行的复制操作多，效率低下，更关键的时浪费的50%的内存空间。如果不想浪费，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般不能直接选择复制算法。</p>
<p><strong>根据老年代的特点(对象存活率高，难于GC)</strong>，出现了“标记-整理”算法。标记过程仍然与“标记-清除”算法一样，但后续步骤中不再直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>回收前：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618624988169-70edd65b-ee72-46f7-b3d3-b5f694f3fde6.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>回收后：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618625050340-f97c4be5-454a-4f86-bb91-6c528c7235ee.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p><strong>在新生代中</strong>，每次垃圾回收都会有大批对象死去，只有少数存活，那就选用复制算法，只要付出少量存活对象的复制成本就可以完成收集。</p>
<p><strong>而老年代</strong>中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。</p>
<h3 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h3><p>众所周知，一般回收内存方法包括计数法、可达性分析法。可达性分析法即GC ROOTS(枚举根结点，找到引用链)。</p>
<p>以此为例，1.枚举的节点主要存在于全局性的引用(如常量)与执行上下文(如栈帧的局部变量表)中，目前很多应用仅方法区就有数百兆，如果逐一检查，必定消耗很多时间。2.另可达性分析对执行时间也很敏感，这就体现在GC的停顿上，因为分析工作必须在一个时间点上，不可以出现分析过程中，对象的引用关系还会发生变化的情况，不然无法保证准确性。这也是导致GC时<strong>必须停顿所有Java执行线程(STOP THE WORLD)</strong>的一个重要原因。</p>
<p>随即引出<strong>安全点</strong>的概念：</p>
<p>在HotSpot中，当执行系统停顿下来后，其会使用一组成为OopMap的数据结构来记录对象的引用，保存对象内什么偏移量上是什么类型的数据，以及<strong>特定位置记录下栈和寄存器中有哪些位置是引用</strong>。这样在GC扫描时，就能直接得知相关信息了。</p>
<p>在OopMap的协助下，HotSpot可以快速准确地完成GC ROOTS枚举，但随着引用关系变化，或者OopMap内容变化的指令太多，如果为每一条指令都生成OopMap指令，那就会需要大量的额外空间。</p>
<p>所以HotSpot也不可能为每条指令都生成OopMap。只有在<strong>特定的位置</strong>才会记录下栈、寄存器信息，这些位置称为<strong>“安全点”(SafePoint)</strong>，即程序执行时并非在所有地方都停顿下来进行GC，只在安全点停顿。</p>
<p><strong>SafePoint的选定既不能太少以至于让GC等待时间太长，也不能太多导致GC过于频繁，加大运行时的负荷。</strong></p>
<p>所以，安全点的选择基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的–因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长就过长时间运行。“长时间执行”的最明显的特征就是指令序列复用，例如：方法调用、循环跳转、异常跳转等(方法返回之前、调用某个方法之后、抛出异常的位置、循环的末尾)。</p>
<p>安全区域：savePoint是对正在执行的线程的设定。如果一个线程处于Sleep或中断状态，它就不能响应JVM的中断请求，会<strong>卡住运行到savePoint上</strong>，因为JVM引入了safe Region。safe Region指的是一段代码片段中，引用关系不会发生变化，在这个区域内的任意地方开始GC都是安全的。</p>
<h2 id="垃圾收集器种类"><a href="#垃圾收集器种类" class="headerlink" title="垃圾收集器种类"></a>垃圾收集器种类</h2><p><strong>HostSpot虚拟机中的垃圾收集器</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618627307192-d8bdd439-baab-4226-b948-0cbfb82ee031.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>注：两个收集器之间存在连线，说明其可以搭配使用。特殊说明：CMS备选老年代收集器可以使用Serial Old。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><strong>-XX:+UseSerialGC</strong> </p>
<p>简介：Serial收集器是最基本、发展历史最悠久的垃圾收集器，曾是虚拟机新生代收集的唯一选择。</p>
<p>Serial串行的、连续的，很明显其代表的是一个单线程收集器。但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或者一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾回收的时候，必须<strong>暂停其所有的</strong>工作线程(STW)，直到它收集结束。</p>
<p>工作运行图：Serial组合Serial Old</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618635052800-2ccf3c53-e825-45d1-9025-693b5bd2eb57.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>注：<strong>新生代、老年代都是单线程</strong></p>
<p><strong>缺点</strong>：Stop The World给用户带来的不良体验，为消除或者减少工作线程因为内存回收而导致停顿的努力一直进行着，所以有了后续的垃圾收集器的出现，但是仍然没办法完全消除。</p>
<p><strong>优点</strong>：与其它单线程收集器相比，其简单而高效。因为Serial没有线程交互的开销，自然可以拥有高效的单线程收集效率。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p><strong>-XX:+UseSerialOldGC</strong></p>
<p>简介：如一开始的收集器连接图，Serial Old收集器是Serial新生代收集器的老年代版本，它同样是一个单线程的收集器，使用的是“标记-整理”算法。其主要意义是给Client模式下的虚拟机使用。</p>
<p>如果在Server 模式下，它有两大用途：</p>
<ul>
<li>在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用</li>
<li>作为CMS收集器的后备预案</li>
</ul>
<p>工作图与Serial收集器一致。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>简介：ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，还包括Serial收集器的控制参数</p>
<p><strong>-XX:+UseParNewGC</strong></p>
<p><strong>-XX:+SurvivorRatio 设置新生代内存的占比</strong></p>
<p><strong>-XX:PretenureSizeThreshold 可直接进入老年代对象大小</strong></p>
<p><strong>-XX:HandlePromotionFailure 老年代空间担保机制开启</strong></p>
<p><strong>以及收集算法，STW，对象分配规则、回收策略等都与Serial收集器其完全一致。</strong></p>
<p>它是运行在Server模式下的新生代收集器的首选，除了Serial收集器之外，目前只有它能够和CMS收集器配合工作</p>
<p>工作运行图：ParNew 组合 Serial Old</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618635237451-8b1e0ea9-0650-4099-a5bd-11a4df1a6b9f.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>注：<strong>新生代多线程，老年代单线程</strong></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>简介：Parallel Scavenge收集器是一个新生代的收集器，也是使用复制算法的收集器，又是并行的多线程收集器。</p>
<p>其特点是它的关注点与其它收集器不同，CMS等收集器是尽可能地<strong>缩短垃圾收时用户线程的停顿时间</strong>，而Parallel Scavenge的目标则是达到一个可以控制的吞吐量(Throughput)。</p>
<p><strong>所谓吞吐量就是CUP用于运行代码的时间与CPU总耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。</strong></p>
<p>Parallel Scavenge提供了多个参数用于找到合适的吞吐量或停顿时间。</p>
<p><strong>-XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间ms</strong></p>
<p><strong>-XX:GCTimeRatio 设置吞吐量大小(垃圾收集时间大小)(0-100的整数，默认99) 假设此参数设置为19，那允许的最大GC时间就占总时间的5%(即 1/（1+19）)</strong></p>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>Parallel Old是Parallel Scavenge的老年代版本，使用多线程和“标记-整理”算法。JDK1.6所提供。一般以吞吐量以及CPU为资源敏感的场合下，都可以优先考虑Parallel Scavenge加Parallel Old的组合。</p>
<p>工作运行图：Parallel Scavenge 组合 Parallel Old</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618636773174-beb16e4e-3401-4874-be0c-f37c4524d98a.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>注：<strong>新生代、老年代都是多线程运行GC</strong></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<p>从名字(“Mark Sweep”)可以看出，CMS收集器是<strong>基于“标记-清除”算法</strong>实现的。</p>
<p>整个过程包括四个步骤：</p>
<ul>
<li><ul>
<li><ul>
<li>初始标记(initial mark):<strong>需要暂停所有线程</strong>(STW)，标记以下GC ROOTS能直接关联到的对象，速度很快。</li>
<li>并发标记(concurrent mark):指的是从GC ROOTS的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长(<strong>占用总时间80%左右</strong>)，但是<strong>不需要STW</strong>，可以与<strong>垃圾收集线程</strong>一起<strong>并发运行</strong>。因为用户程序继续运行，可能会导致已经标记过的对象状态发生改变。</li>
<li>重新标记(remark):<strong>需要暂停所有线程</strong>(STW)。指的是为了<strong>修正</strong>并发标记期间<strong>因为用户程序继续运行</strong>而导致标记<strong>产生变动</strong>的那一部分对象的标记记录，而且这个停顿时间一般会比初始标记的时间稍长，远远比并发标记的时间短。(三色标记)</li>
<li>并发清除(concurrent sweep):开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理。(三色标记)</li>
<li>并发重置(reset):重置本次GC过程中的标记数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>工作运行图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1618728113747-42b8e99d-4c42-496b-94d0-222b3ecca799.png?x-oss-process=image%2Fresize%2Cw_1500" alt="image" title="">
                </div>
                <div class="image-caption">image</div>
            </figure>

<p>优点：</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li>并发收集</li>
<li>低停顿感，将停顿分为好几次，给用户零感触</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>​        对CPU资源敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为<strong>占用了一部分线程</strong>(或者说CPU资源)而导致应用程序变慢，<strong>总吞吐量会降低</strong>。如果CPU数量较少时，如2个CPU，需要分出一半的运算能力区执行收集器线程，就会导致用户程序的执行速度忽然降低50%。<ul>
<li>无法处理浮动垃圾。在并发标记和并发清理阶段又产生的垃圾，这种垃圾会导致另一次Full GC的产生，即下一次gc处理。</li>
<li>接上一点。如果在运行期间预留的内存无法满足程序需要时，就会出现一次“Concurrent Mode Failure”并发失败。即在上一次垃圾回收还没执行完时，然后垃圾回收又被触发的情况，<strong>特别是产生浮动垃圾的时候</strong>(并发标记和并发清理阶)，一边回收，系统一边运行，没回收完就再次触发了Full GC，此时就会<strong>进入STW，临时启用Serial Old收集器来重新进行老年代的垃圾收集，这里会一直等待收集完成(等待时间很长)。</strong></li>
<li><strong>基于“标记-清除”的算法，会导致收集结束时会有大量空间碎片产生。空间碎片过多，给大对象分配内存带来很大麻烦，如果没有内存则会触发Full GC。</strong></li>
</ul>
</li>
</ul>
<p><strong>解决：-XX:+UseCMSCompactAtFullCollection 默认开启，用于CMS在顶不住要进行Full GC时开启内存随便的合并整理过程。配合</strong>-XX:CMSFullGCsBeforeCompaction使用。</p>
<p>CMS的相关核心参数 </p>
<p>\1. -XX:+UseConcMarkSweepGC：启用cms </p>
<p>\2. -XX:ConcGCThreads：并发的GC线程数 </p>
<p>\3. -XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片） </p>
<p>\4. -XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是0，代表每次FullGC后都会压缩一 </p>
<p>次</p>
<p>\5. -XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（jdk1.6默认是92，这是百分比） </p>
<p>\6. -XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设 </p>
<p>定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整 </p>
<p>\7. -XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引 </p>
<p>用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段 </p>
<p>\8. -XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW </p>
<p>\9. -XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW; </p>
<h1 id="JVM调优工具及了解"><a href="#JVM调优工具及了解" class="headerlink" title="JVM调优工具及了解"></a>JVM调优工具及了解</h1><h2 id="常见的调优指令"><a href="#常见的调优指令" class="headerlink" title="常见的调优指令"></a>常见的调优指令</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>查看应用程序对应的进程id</p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>查看内存信息，实例个数，占用内存的大小等</p>
<p>jmap -histo 27500(可添加 <strong>&gt; ./testLog.txt</strong> 生成txt到当前目录下)</p>
<ul>
<li><p>num：序号 </p>
</li>
<li><p>instances：实例数量 </p>
</li>
<li><p>bytes：占用空间大小 </p>
</li>
<li><p>class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][]</p>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1619101930292-3e6146ce-8b0a-45a9-9287-5fe6ccc86e71.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<h4 id="堆-2"><a href="#堆-2" class="headerlink" title="堆"></a>堆</h4><p>查看堆信息：jmap -heap 27500</p>
<p>堆快照dump：jmap -dump:format=b,file=xxx.hprof 27500</p>
<p>设置堆内存溢出自动dump：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=./（生成文件路径）</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>得到运行java程序的java stack和native stack的信息</p>
<p>格式： </p>
<p>jstack [ option ] pid </p>
<p>jstack [ option ] executable core </p>
<p>jstack [ option ] [server-id@]remote-hostname-or-IP </p>
<p>场景：</p>
<p>1死锁，Deadlock</p>
<p>2等待资源，Waiting on condition</p>
<p>• 等待获取监视器，Waiting on monitor entry </p>
<p>3阻塞，Blocked（重点关注） </p>
<p>• 执行中，Runnable </p>
<p>• 暂停，Suspended </p>
<p>• 对象等待中，Object.wait() 或 TIMED_WAITING </p>
<p>• 停止，Parked </p>
<p>查看程序cpu及内存使用情况</p>
<p>top -p <pid></p>
<p>执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调用方法 </p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>查看jvm的参数：jinfo -flags <pid></p>
<p>查看java程序的参数：jinfo -sysprops <pid></p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>以查看堆内存各部分的使用量，以及加载类的数量。(注意：使用的jdk版本是jdk8 )</p>
<p>命令格式： jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数] </p>
<p>常用指令：</p>
<p>查看程序内存使用及GC压力整理情况：jstat -gc pid</p>
<p>查看堆内存统计：jstat -gccapacity pid</p>
<p>查看新生代内存统计：jstat -gcnewcapacity pid</p>
<p>查看新生代垃圾回收统计：jstat -gcnew pid</p>
<p>查看老年代内存统计：jstat -gcoldcapacity pid</p>
<p>查看老年代垃圾回收统计：jstat -gcold pid</p>
<p>查看元数据空间统计：jstat -gcmetacapacity pid</p>
<h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><p>1导入dump文件分析堆信息</p>
<p>2线程dump，查看当前线程运行信息</p>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p> 先给自己的系统设置一些初始性的 JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。</p>
<h3 id="1-年轻代对象增长的速率"><a href="#1-年轻代对象增长的速率" class="headerlink" title="1.年轻代对象增长的速率"></a>1.年轻代对象增长的速率</h3><p>jstat -gc pid 1000 10(每隔1s执行1次，共执行10次)观察EU区的使用，来估算每秒Eden区大概有多少新增的对象。当系统负荷不高时，可以将执行时间调大到1分钟甚至10分钟来观察。</p>
<h3 id="2-young-gc触发的频率和单次耗时时间"><a href="#2-young-gc触发的频率和单次耗时时间" class="headerlink" title="2.young gc触发的频率和单次耗时时间"></a>2.young gc触发的频率和单次耗时时间</h3><p>公式：触发频率=YGCT/YGC（jstat命令可查看，YGCT young gc总耗时单位s，YGC young gc次数）</p>
<h3 id="3-每次young-gc后有多少对象是存活的且进入老年代"><a href="#3-每次young-gc后有多少对象是存活的且进入老年代" class="headerlink" title="3.每次young gc后有多少对象是存活的且进入老年代"></a>3.每次young gc后有多少对象是存活的且进入老年代</h3><p>从第二点中知道young gc频率，如果是10分钟一次那么 jstat -gc pid 600000 10，就可以通过该指令查看gc中，每次Eden区、Survivor、老年代区的使用及变化情况。众所周知，每次gc后，eden区存活对象减少，Survivor、老年代都有可能增长，这些增长的对象就是每次young gc后存活的对象，可以看出每次young gc有多少存活的对象是进入到老年代中的，推算出老年代的增长速率。</p>
<h3 id="4-Full-GC的触发频率和单次耗时时间"><a href="#4-Full-GC的触发频率和单次耗时时间" class="headerlink" title="4.Full GC的触发频率和单次耗时时间"></a>4.Full GC的触发频率和单次耗时时间</h3><p>公式：触发频率=FGCT/FGC（FGCT full gc总耗时单位s，FGC full gc次数）</p>
<p>思路：基本看来就是</p>
<p>1尽量让每次young gc后的存活对象小于Survivor区域的50%，将存活对象留在新生代中，尽量别让对象进入老年代中。</p>
<p>2尽量减少full gc的频率，避免频繁full gc对jvm性能的影响。</p>
<p>3新生代或者老年代的增长过快之类的，回顾其内存分配时注意的一些点，</p>
<h1 id="常量池了解"><a href="#常量池了解" class="headerlink" title="常量池了解"></a>常量池了解</h1><h2 id="Class常量池（class-constant-pool）"><a href="#Class常量池（class-constant-pool）" class="headerlink" title="Class常量池（class constant pool）"></a>Class常量池（class constant pool）</h2><p>定义：class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。</p>
<p>通过javap -v xxx.class 反编译字节码生成可读的JVM字节码指令文件</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1619447796774-ecb4e7fb-a3c3-463a-b24a-37b7ca0bddc3.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>

<p>其中<strong>Constant pool</strong>指的就是class常量池的信息，常量池中主要存放的是两大类常量：<strong>字面量和符号引用</strong>。</p>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>指的是<strong>常量概念</strong>，如文本字符串、字母、数字以及被声明为final的常量值等。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h3 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h3><p><strong>符号引用</strong>是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它<strong>与直接引用</strong>区分一下，直接引用一般是指向<strong>方法区的本地指针</strong>，相对偏移量或是一个能间接定位到目标的句柄）。</p>
<p>一般包括下面三类常量：</p>
<ul>
<li><p>类和接口的全限定名</p>
</li>
<li><p>字段的名称和描述符</p>
</li>
<li><p>方法的名称和描述符</p>
</li>
</ul>
<p>如上面的两个常量a，b是字段的名称，就是一种符号引用，还有类的全限定名(常量池中的      Lcom/gx/demo/jvm/MyMath)，caculate、main都是方法的名称，()V 等都是符号引用。</p>
<p>当然，常量池中的信息都是静态信息，只有真正的在运行时被加载到内存后，这些符号才会有<strong>对应的内存地址信息</strong>，这些常量池一旦被装入内存就变成了<strong>运行时常量池，</strong>对应的<strong>符号引用</strong>在<strong>程序加载或者运行</strong>的时候会被转变为被加载到内存区域的代码的<strong>直接引用</strong>，即<strong>动态链接</strong>。（符号引用转变为了内存中地址的直接引用，主要是通过<strong>对象头</strong>里的Klass pointer类型指针去转换直接引用）</p>
<h2 id="运行时常量池（runtime-constant-pool）"><a href="#运行时常量池（runtime-constant-pool）" class="headerlink" title="运行时常量池（runtime constant pool）"></a>运行时常量池（runtime constant pool）</h2><p>java文件被编译为class文件，即产生上面所述的class常量池。</p>
<p>运行时常量池如何产生？</p>
<p>回顾类加载过程：<strong>加载(load)&gt;&gt;链接(link)(验证&gt;&gt;准备&gt;&gt;解析)&gt;&gt;初始化(initialize)&gt;&gt;使用&gt;&gt;卸载</strong></p>
<p>而当类被加载内存中的时候，JVM会将class常量池中的内容放到运行时常量池中，因此，几乎每一个类都存在于运行时常量池中。真正的<strong>将符号引用变成内存地址的直接引用</strong>是发生在<strong>解析</strong>的时候，解析的过程会去<strong>查询全局字符串池</strong>，也就是StringTable（<strong>字符串常量池的概念</strong>），以保证运行时常量池所引用的字符串与字符串常量池中所引用的是一致。</p>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>1.字符串对象的分配，和其它的对象分配一样，都需要耗费极大的时间与空间代价。且作为最基础的数据类型之一，大量频繁的创建字符串，极大程度地影响了程序的性能。</p>
<p>2.JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化</p>
<ul>
<li>为字符串开辟一个字符串常量池，类似于缓存区</li>
<li>当创建一个字符串常量时，首先查询该字符串常量是否已存在于字符串常量池中</li>
<li>当存在该字符串时，返回其引用实例；不存在时，则将该字符串实例化，并放入字符串常量池中</li>
</ul>
<h3 id="三种字符串操作"><a href="#三种字符串操作" class="headerlink" title="三种字符串操作"></a>三种字符串操作</h3><p>1.直接赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"gx"</span>;</span><br></pre></td></tr></table></figure>

<p>直接赋值创建的方式，只会存在于常量池中。<strong>str指向的是常量池中的引用</strong></p>
<p>“gx”直接给到了值，当创建对象str时，JVM会先去常量池中通过equals(key)方法，寻找是否有相同的对象。</p>
<p>如果有，则直接返回该对象在常量池中的引用。</p>
<p>如果没有，则会先创建一个新对象于常量池中，再返回其引用。</p>
<p>2.new关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"gx"</span>);</span><br></pre></td></tr></table></figure>

<p>由于new对象，所以这种方式会在堆和字符串常量池中都拥有这个对象，没有就会创建，最后再返回<strong>堆内存中的对象引用。str指向的是内存中的对象引用</strong></p>
<p>生成步骤：</p>
<p>a.“gx”直接给到了值,于直接赋值一样，先去池中寻找是否存在字符串“gx”。</p>
<p>b.如果不存在，先在字符串常量池中创建一个字符串对象；再去堆内存中创建一个字符串对象“gx”。</p>
<p>c.如果存在，直接去堆内存中创建一个字符串对象“gx”。</p>
<p>d.将内存中的引用返回给变量。</p>
<p>3.intern()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"gx"</span>);</span><br><span class="line">String str1 = str.intern();</span><br><span class="line">System.out.println(str == str1); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>  String中的intern方法是一个 native 的方法，当调用 intern方法时，如果池已经包含一个等于此String对象的字符串 用equals(object)方法确定），则返回池中的字符串。否则将被加入池中并返回这个引用给变量。(jdk1.6版本需要将s1 复制到字符串常量池里)。 </p>
<h3 id="字符串常量池位置"><a href="#字符串常量池位置" class="headerlink" title="字符串常量池位置"></a>字符串常量池位置</h3><p>Jdk1.6及之前： 有永久代, 运行时常量池在永久代，运行时常量池包含字符串常量池 </p>
<p>Jdk1.7：有永久代，逐步开始抛弃方法区,将字符串常量池移至堆区.这里jdk文档并没有说运行时常量池是否也跟着移到堆区,也就是说运行时常量依然在方法区</p>
<p>Jdk1.8及之后： 无永久代，运行时常量池在元空间，字符串常量池里依然在堆里 </p>
<h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><p>字符串常量池底层是hotspot的C++实现的，底层类似一个 HashTable， 保存的本质上是字符串对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"gx"</span>);</span><br><span class="line">String str1 = str.intern();</span><br><span class="line">System.out.println(str == str1);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"bc"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>先说示例2：</p>
<p>依据JDK的版本不同，所涉及创建的string对象多少也不同。</p>
<p>在JDK1.6及之前，因为有永久代的存在，<strong>常量池是存在于永久代中</strong>的，故此当调用intern()方法，即先去<strong>字符串常量池</strong>中寻找相等的字符串，如果<strong>存在则返回该字符串的引用</strong>，否则，<strong>会在永久代重新建立一个实例</strong>，将StringTable的一个表指向这个新创建的实例。</p>
<p>在JDK1.7及以后，由于字符串池不在存放于永久代了，intern() 有所变动，更方便地利用堆中的对象。字符 </p>
<p>串存在时和 JDK 1.6一样，但是<strong>字符串不存在时不再需要重新创建实例</strong>，可以直接<strong>指向堆上</strong>的实例。</p>
<p>因此这里 JDK1.6 创建了6个对象 常量池：“a” “bc” “abc”(<strong>abc常量池中没有新建了</strong>) 堆：“a” “bc” “abc”</p>
<p> JDK1.7后创建了5个对象 常量池：“a” “bc” (<strong>abc常量池中没有指向堆中的</strong>) 堆：“a” “bc” “abc”</p>
<p>(注意：是去<strong>字符串常量池</strong>中寻找)</p>
<p>所以s1.intern() 拿到的是堆中的“abc” 和 s1一致</p>
<p>示例1:</p>
<p>同理，str指向的是堆中的引用，str1是获取的字符串常量池中的引用，不一致</p>
<h3 id="常见字符串比较问题"><a href="#常见字符串比较问题" class="headerlink" title="常见字符串比较问题"></a>常见字符串比较问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">String ss1 = <span class="string">"gx"</span>;</span><br><span class="line">String ss2 = <span class="string">"gx"</span>;</span><br><span class="line">String ss3 = <span class="string">"g"</span>+<span class="string">"x"</span>;</span><br><span class="line">System.out.println(ss1 == ss2);<span class="comment">//true</span></span><br><span class="line">System.out.println(ss1 == ss3);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//基本都是字符串常量，在编译期间就被确定了。"g"+"x"都是常量，当由多个常量组合的时候，</span></span><br><span class="line"><span class="comment">//它也是个常量，在编译期间会被优化成“gx”</span></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">String ss4 = <span class="keyword">new</span> String(<span class="string">"gx"</span>);</span><br><span class="line">String ss5 = <span class="string">"g"</span> + <span class="keyword">new</span> String(<span class="string">"x"</span>);</span><br><span class="line">System.out.println(ss1 == ss4);<span class="comment">//false</span></span><br><span class="line">System.out.println(ss1 == ss5);<span class="comment">//false</span></span><br><span class="line">System.out.println(ss4 == ss5);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//新建的字符串对象，而非常量，在编译期间无法确定，不是放在常量池中，有自己的内存地址。</span></span><br><span class="line"><span class="comment">//ss5也包含新对象，无法确定，是内存地址</span></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">String ss6 = <span class="string">"gx1"</span>;</span><br><span class="line">String ss7 = <span class="string">"gx"</span> + <span class="number">1</span>;</span><br><span class="line">System.out.println(ss6 == ss7);<span class="comment">//true</span></span><br><span class="line">String ss8 = <span class="string">"gx1.1"</span>;</span><br><span class="line">String ss9 = <span class="string">"gx"</span> + <span class="number">1.1</span>;</span><br><span class="line">System.out.println(ss8 == ss9);<span class="comment">//true</span></span><br><span class="line">String ss10 = <span class="string">"gxxx"</span>;</span><br><span class="line">String ss11 = <span class="string">"gx"</span> + <span class="string">"xx"</span>;</span><br><span class="line">System.out.println(ss10 == ss11);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//JVM对于字符串常量的"+"号连接，将在程序编译期，JVM就将常量字符串的"+"连接优化为连接后的值</span></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">String ss12 = <span class="string">"gxxx"</span>;</span><br><span class="line">String ss13 = <span class="string">"xx"</span>;</span><br><span class="line">String ss14 = <span class="string">"gx"</span> + ss13;</span><br><span class="line">System.out.println(ss12 == ss14);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//字符串引用，由于在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的</span></span><br><span class="line"><span class="comment">//"gx" + ss13无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以结果为 false。</span></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">String ss15 = <span class="string">"gxxx"</span>;</span><br><span class="line"><span class="keyword">final</span> String ss16 = <span class="string">"xx"</span>;</span><br><span class="line">String ss17 = <span class="string">"gx"</span> + ss16;</span><br><span class="line">System.out.println(ss15 == ss17);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中</span></span><br></pre></td></tr></table></figure>

<p>编译期间 常量间的 “+” 会被优化，但对象间的“+”等同于stringbuilder 即new string</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.nlark.com/yuque/0/2021/png/705191/1620393652919-436b2c76-ae28-4618-a792-d307cadd4af6.png?x-oss-process=image%2Fresize%2Cw_1500" alt="屏幕快照 2021-05-07 下午9.18.12.png" title="">
                </div>
                <div class="image-caption">屏幕快照 2021-05-07 下午9.18.12.png</div>
            </figure>



<h2 id="八大基本类型和对象池"><a href="#八大基本类型和对象池" class="headerlink" title="八大基本类型和对象池"></a>八大基本类型和对象池</h2><p>(1) int==========&gt;Integer</p>
<p>(2) short========&gt;Short</p>
<p>(3) long========&gt;Long</p>
<p>(4) byte========&gt;Byte</p>
<p>(5) char========&gt;Character</p>
<p>(6) float========&gt;Float</p>
<p>(7) double=======&gt;Double</p>
<p>(8) boolean=======&gt;Boolean</p>
<p>基本类型的包装类型基本都实现了常量池技术（对象池），除了Float和Double两种浮点数类型。</p>
<p>另外实现了的5种包装类型也只能在对应值小于127的时候才会使用对象池，即对象池不负责创建和管理大于127的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">127</span>;</span><br><span class="line">Integer i2 = <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">Integer i3 = <span class="number">128</span>;</span><br><span class="line">Integer i4 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">System.out.println(i5 == i6);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">Boolean b1 = <span class="keyword">false</span>;</span><br><span class="line">Boolean b2 = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(b1 == b2);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">Float f1 = <span class="number">1.1f</span>;</span><br><span class="line">Float f2 = <span class="number">1.1f</span>;</span><br><span class="line">System.out.println(f1 == f2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2021-06-09T14:54:14.021Z" itemprop="dateUpdated">2021-06-09 22:54:14</time>
</span><br>


        
        <a href="/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/</a>
        
    </div>
    
    <footer>
        <a href="https://github.com/flyinglions-zsl/flyinglions-zsl.github.io">
            <img src="/img/logo.png" alt="flyinglions-zsl">
            flyinglions-zsl
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/&title=《JVM学习》 — Zhousl's Blog&pic=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/img/logo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/&title=《JVM学习》 — Zhousl's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JVM学习》 — Zhousl's Blog&url=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/&via=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2021/04/03/lamda%E5%B8%B8%E7%94%A8%E7%82%B9%E8%AE%B0%E5%BD%95/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">lamda常用点记录</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2021/01/27/rabbitmq01/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">rabbitmq01</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wx_money.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wx_money.jpg" data-alipay="/img/zfb_money.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>flyinglions-zsl &copy; 2020 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/&title=《JVM学习》 — Zhousl's Blog&pic=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/img/logo.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/&title=《JVM学习》 — Zhousl's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JVM学习》 — Zhousl's Blog&url=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/&via=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://github.com/flyinglions-zsl/flyinglions-zsl.github.io/2021/03/28/JVM%E5%AD%A6%E4%B9%A0/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
