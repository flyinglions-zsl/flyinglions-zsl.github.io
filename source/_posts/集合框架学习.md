---
title: é›†åˆæ¡†æ¶å­¦ä¹ 
date: 2021-07-16 22:43:18
tags: 
	- é›†åˆ
categories:
	- é›†åˆ
---

# HashMap

## 1.7ç‰ˆæœ¬åˆ†æ

### æ•°æ®ç»“æ„å®ç°

æ•°ç»„(åŸºæœ¬)+é“¾è¡¨(æ‰©å±•)

### å±æ€§

```
//é»˜è®¤hashè¡¨å®¹é‡å¤§å° 2^4=16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
//æœ€å¤§hashè¡¨å®¹é‡å¤§å°ï¼Œå¿…é¡»æ˜¯2çš„æ•´æ•°å¹‚
static final int MAXIMUM_CAPACITY = 1 << 30;
//é»˜è®¤åŠ è½½å› å­
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//è¡¨æœªè†¨èƒ€æ—¶å…±äº«çš„ç©ºè¡¨å®ä¾‹ã€‚
static final Entry<?,?>[] EMPTY_TABLE = {};
//hashè¡¨resizeï¼Œå¤§å°å¿…é¡»æ˜¯2çš„æ•´æ•°å¹‚
transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;
//è¡¨ä¸­å­˜åœ¨çš„key-valueå¯¹å®ä¾‹æ•°é‡
transient int size;
//resizeçš„é˜ˆå€¼ (capacity * load factor)
int threshold;
//hashè¡¨çš„åŠ è½½å› å­
final float loadFactor;
//ä¿®æ”¹çš„æ¬¡æ•°ï¼Œæ›´å¤šåœ¨äºè¿­ä»£æ—¶ä½¿ç”¨ï¼Œ fail-fastæœºåˆ¶
transient int modCount;
//mapå®¹é‡çš„é»˜è®¤é˜ˆå€¼ï¼Œé«˜äºè¯¥é˜ˆå€¼çš„æ›¿ä»£æ•£åˆ—æ˜¯ç”¨äºå­—ç¬¦ä¸²é”®ã€‚
//æ›¿ä»£å“ˆå¸Œé™ä½äº†å‘ç”Ÿç‡ç”±äºå­—ç¬¦ä¸²é”®çš„å¼±å“ˆå¸Œç è®¡ç®—è€Œå¯¼è‡´çš„å†²çªã€‚
static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;
//hashç§å­åˆå§‹å€¼
transient int hashSeed = 0;
```



### æ„é€ æ–¹æ³•

```
//åŸºæœ¬åŸºäºè¿™ä¸ªæ–¹æ³•ï¼Œå¦‚ï¼šHashMap()ï¼Œé»˜è®¤16ï¼Œ0.75f
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    //æœ€å¤§ä¹Ÿåªæœ‰2^30
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    this.loadFactor = loadFactor;
    //resizeçš„é˜ˆå€¼ å°±æ˜¯ç»™å®šçš„åˆå§‹å®¹é‡
    threshold = initialCapacity;
    //é’©å­æ–¹æ³•
    init();
}
```



### é‡è¦æ–¹æ³•

#### put

```
public V put(K key, V value) {
    //åˆ¤æ–­æ˜¯å¦æ²¡å­˜æ”¾å…ƒç´ 
    if (table == EMPTY_TABLE) {
        //åˆå§‹åŒ–æ•°ç»„è¡¨ï¼Œé˜ˆå€¼ï¼Œhashç§å­
        inflateTable(threshold);
    }
    if (key == null)
        //å¯å­˜å‚¨keyä¸ºnullçš„ï¼Œå¦‚æœæ²¡å­˜åˆ™ä¼šä¸“é—¨åˆ›å»ºä¸€ä¸ªentryåœ¨bucketä¸­ä¸”indexä¸º0.
        //æœ‰äº†åˆ™æ›¿æ¢value
        return putForNullKey(value);
    //é€šè¿‡ä½è¿ç®—(è®¡ç®—æœºåº•å±‚è¿ç®—ï¼Œè¿œæ¯”%é€Ÿåº¦å¿«) å¾—åˆ°hashæ•£åˆ—å€¼
    int hash = hash(key);
    //é€šè¿‡hashå€¼ ä¸ è¡¨é•¿åº¦-1(åº•å±‚æ–¹æ³•) è¿›è¡Œä¸è¿ç®—ï¼Œæ§åˆ¶ä¸‹æ ‡ä¸€å®šä¼šåœ¨é•¿åº¦èŒƒå›´å†…
    //å¦‚key='a'æ—¶ï¼Œhash=103ï¼Œlength-1=15ï¼›0110 0111&0000 1111 = 0000 0111=7
    int i = indexFor(hash, table.length);
    //æ‹¿åˆ°å½“å‰æ•°ç»„ä¸‹æ ‡ä½ä¸Šçš„é“¾è¡¨ï¼Œæ²¡æœ‰åˆ™è·³è¿‡ï¼Œå¦åˆ™ä»¥å®ƒæ˜¯å¦æœ‰ä¸‹ä¸€èŠ‚ç‚¹æ¥è¿›è¡Œéå†
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        //å…ˆåˆ¤æ–­keyæ˜¯å¦ä¸€è‡´ï¼Œæ˜¯åˆ™ç”¨æ–°å€¼æ›¿æ¢æ—§å€¼
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    //åœ¨æ­¤hashæ–°å¢ä¸€ä¸ªentryï¼Œåº•å±‚createEntryæ–¹æ³•ï¼Œå¦‚æœå½“å‰indexå¤„å·²ç»æœ‰äº†entry
    //é‚£Entry<K,V> e = table[bucketIndex]; ä¼šå…ˆæ‹¿åˆ°å½“å‰indexçš„entryï¼Œå³ä¸Šä¸€æ¬¡æ·»åŠ çš„
    //table[bucketIndex] = new Entry<>(hash, key, value, e);å†å°†ä¸Šä¸€æ¬¡çš„entryè®¾ç½®ä¸º
    //æ–°å¢çš„entryçš„nextï¼Œä¸”å°†æ–°å¢çš„entryè®¾ç½®ä¸ºå½“å‰indexçš„é¦–ä¸ªå…ƒç´ (å¤´æ’æ³•)
    //(å³æ¯æ¬¡æ–°å¢çš„éƒ½ä¼šæˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä½äºæ•°ç»„ä¸‹æ ‡å¤„)
    addEntry(hash, key, value, i);
    return null;
}

private void inflateTable(int toSize) {
    // Find a power of 2 >= toSize æ ¹æ®å½“å‰çš„é˜ˆå€¼å¾—åˆ°2çš„æ•´æ•°å¹‚
    int capacity = roundUpToPowerOf2(toSize);
	//è®¾ç½®æ–°çš„é˜ˆå€¼ capacity * loadFactor
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    //è®¾ç½®æ–°çš„å®¹é‡å¤§å°
    table = new Entry[capacity];
    //åˆå§‹åŒ–hashç§å­
    initHashSeedAsNeeded(capacity);
}

final int hash(Object k) {
    //åˆå§‹å€¼ä¸º0ï¼Œputã€æ‰©å®¹ä¼šè®¡ç®—æœ‰å€¼
    int h = hashSeed;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
//è·å–å½“å‰å®¹é‡ä¸‹çš„hash ç´¢å¼•
static int indexFor(int h, int length) {
    return h & (length-1);
}
```

#### putæµç¨‹å›¾

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626853410085-148a0c47-6fbb-483c-abc6-3da2e5a022a0.png)



#### get

```
public V get(Object key) {
    //ç‰¹æ®Šçš„ï¼škeyä¸ºnull
    if (key == null)
        return getForNullKey();
    //
    Entry<K,V> entry = getEntry(key);

    return null == entry ? null : entry.getValue();
}

final Entry<K,V> getEntry(Object key) {
    if (size == 0) {
        return null;
    }
	//åŒæ ·çš„å…ˆæ ¹æ®keyå¾—åˆ°hashå€¼
    int hash = (key == null) ? 0 : hash(key);
    //å†è®¡ç®—å‡ºindexï¼Œå»æ•°ç»„ä¸­å¯¹åº”çš„ä¸‹æ ‡æ‹¿ entryæ•°ç»„éå†
    for (Entry<K,V> e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        //æ‹¿åˆ°ç›¸åŒhashå€¼çš„ entryï¼Œæ²¡æœ‰åˆ™è¿”å›null
        if (e.hash == hash &&
            ((k = e.key) == key || (key != null && key.equals(k))))
            return e;
    }
    return null;
}
```

### å…¥é˜Ÿæ•°ç»„&æ‰©å®¹å®ç°

ä¸Šè¿°putæºç æ—¶ï¼Œåˆ†æäº†å½“hashç¢°æ’æ—¶ï¼Œé“¾è¡¨çš„æ’å…¥ä¸ºå¤´éƒ¨æ’å…¥æ³•ï¼Œå³**æ¯æ¬¡æ–°å¢çš„keyéƒ½æ˜¯é“¾è¡¨å¤´èŠ‚ç‚¹**ã€‚

#### æ‰©å®¹æºç 

```
void resize(int newCapacity) {
    //ä¿å­˜æ—§æ•°ç»„
    Entry[] oldTable = table;
    //ä¿å­˜æ—§å®¹é‡
    int oldCapacity = oldTable.length;
    //ä½œä¸‹å®¹é‡åˆ¤æ–­å¤„ç†ï¼Œå¦‚æœæ—§å®¹é‡å·²ç»æ˜¯æœ€å¤§äº†ï¼Œåˆ™è®¾ç½®é˜ˆå€¼ä¸ºæœ€å¤§ä¸”ç›´æ¥è¿”å›
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
	//ç”¨æ–°å®¹é‡åˆ›å»ºçš„æ–°æ•°ç»„
    Entry[] newTable = new Entry[newCapacity];
    //initHashSeedAsNeeded ç”¨æ–°å®¹é‡å¾—åˆ°æ–°çš„hashç§å­
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    //å°†æ–°æ•°ç»„æ›¿æ¢æ—§çš„æ•°ç»„
    table = newTable;
    //é˜ˆå€¼è®¾ç½®ä¸º2*æ—§å®¹é‡*0.75 ä¸ æœ€å¤§å–å°
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}
//çœŸæ­£çš„ä»æ—§åˆ°æ–°çš„è½¬æ¢
void transfer(Entry[] newTable, boolean rehash) {
    //2*æ—§å®¹é‡
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        //éå†hashè¡¨ä¸­æ¯ä¸ªä½ç½®(ä¸‹æ ‡)ä¸Šçš„é“¾è¡¨
        while(null != e) {
            //è®°å½•æ—§çš„next
            Entry<K,V> next = e.next;
            if (rehash) {
                //é‡æ–°è®¡ç®—hashå€¼
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            //æ ¹æ®ä¸Šé¢è®¡ç®—çš„hashå€¼ & æ–°å®¹é‡ è®¡ç®—æ–°hashæ¡¶ä¸­çš„ä¸‹æ ‡ä½ç½®
            int i = indexFor(e.hash, newCapacity);
            //å¤´æ’æ³•ï¼Œæ‰€ä»¥éœ€è¦å°†ä¹‹å‰å¯èƒ½æœ‰çš„entryæ”¾åˆ°eçš„nextå»
            e.next = newTable[i];
            //å°†å½“å‰eæ”¾åˆ°hashè¡¨ä¸­iä½ç½®å¤´éƒ¨
            newTable[i] = e;
            //ç»§ç»­éå†
            e = next;
        }
    }
}
```

#### å•çº¿ç¨‹put&æ‰©å®¹å›¾

å‡è®¾ï¼šæœ‰ä¸€ä¸ªé•¿åº¦ä¸º2çš„hashè¡¨ï¼Œå·²æœ‰çš„æ•°æ®å¦‚å›¾1.1

æ‰©å®¹ï¼šç»§ç»­putæ•°æ®(k4,v4)ï¼ŒæŒ‰hashmapçš„æ‰©å®¹(å³æ—§å®¹é‡*2)

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626940538262-9f6c0cf2-c2e0-4254-a3ff-3adb8306810f.png)

å›¾1.1

æ‰©å®¹&è½¬ç§»æ•°æ®åˆ°æ–°tableä¸­

ç¬¬ä¸€æ­¥è½¬ç§»k1ï¼š

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626940720362-fa6456b3-9f83-4ad9-b62c-973104ccbc90.png)

ç¬¬äºŒæ­¥è½¬ç§»k2ï¼š

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626940830940-55fe3cc4-dac3-43f6-a342-57c0569d01c3.png)

ç¬¬ä¸‰æ­¥è½¬ç§»k3ï¼š

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626940983184-cda0313d-bf98-451c-8806-1c149fd5a77b.png)

ç¬¬å››æ­¥putï¼š

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626941978112-e27f7452-9ca9-4f58-a9c4-f649534e9417.png)

#### å¤šçº¿ç¨‹put&æ‰©å®¹å›¾

åœºæ™¯ï¼šåœ¨å›¾1.1çš„åŸºç¡€ä¸Šï¼Œæœ‰ä¸¤ä¸ªçº¿ç¨‹**T1**å’Œ**T2**åŒæ—¶è¿›è¡Œputï¼Œç„¶åéœ€è¦æ‰©å®¹çš„æ“ä½œã€‚

ç»“åˆä»£ç (ä¸»è¦å°±æ˜¯whileå¾ªç¯é‡Œ)

**1.å½“T1åœ¨No.1è¡ŒæŒ‚èµ·äº†çš„æ—¶å€™**ï¼Œæ­¤æ—¶çš„T1å’ŒT2å¦‚ä¸‹å›¾2.1å’Œå›¾2.2

ç”±äºT1ä¸­æ˜¯æ—§çš„hashè¡¨ï¼Œe=k1,next=k2,è€ŒT2å·²ç»è½¬æ¢è¿‡å»æ–°hashè¡¨äº†ã€‚

å›¾2.1

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626945465294-153d35d5-11ba-490c-8152-badaf511cfe8.png)

å›¾2.2

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1627013327542-1f193ecd-cf63-43ec-9372-7d16ffc7be82.png)

2.T1åœ¨æ­¤æ—¶è¢«å”¤é†’(e=k1,next=k2)

2.1å®ƒå·²ç»æ–°å»ºäº†ä¸€ä¸ªhashæ•°ç»„ï¼Œå½“è®¡ç®—äº†hashå¹¶æ‰§è¡Œåˆ°e.next = newTable[i]æ—¶ï¼Œk1çš„nextæŒ‡å‘çš„æ˜¯T1çº¿ç¨‹ä¸­çš„æ–°hashè¡¨(å…¨éƒ¨ä¸ºç©ºï¼Œå¦‚å›¾2.1)ï¼Œindex=3å¤„çš„å¤´éƒ¨å…ƒç´ ä¸ºnullï¼Œå³e.next=null

2.2å½“æ‰§è¡Œåˆ°newTable[i] = e; å°†index=3å¤„è®¾ç½®ä¸ºk1ã€‚

2.3å½“æ‰§è¡Œåˆ°e = next; å³e=k2ã€‚æ­¤æ—¶çŠ¶æ€å¦‚å›¾2.3

å›¾2.3

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1627021815404-b1f46cd5-c960-4871-89ce-7bd495cfb774.png)

2.4ç»§ç»­å¾ªç¯ï¼Œe=k2,e.next=k1, æ‰§è¡Œe.next = newTable[i],å³e.next=k1

2.5å½“æ‰§è¡Œåˆ°newTable[i] = e; å°†index=3å¤„å¤´å…ƒç´ è®¾ç½®ä¸ºk2ã€‚

2.6å½“æ‰§è¡Œåˆ°e = next; å³e=k1ã€‚æ­¤æ—¶çŠ¶æ€å¦‚å›¾2.4

å›¾2.4

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1627022071679-18387b4e-8d90-4264-9a16-7e3eaa748667.png)

2.7ç»§ç»­å¾ªç¯ï¼Œe=k1,e.next=null, 

æ‰§è¡Œe.next = newTable[i],å³e.next=k2(**å³k1åˆä¼šæŒ‡å‘k2ï¼Œæ­¤æ—¶ğŸ‰‘k2çš„nextæŒ‡å‘çš„æ˜¯k1**)

2.8å½“æ‰§è¡Œåˆ°newTable[i] = e; å°†index=3å¤„å¤´å…ƒç´ è®¾ç½®ä¸ºk1ã€‚

2.9å½“æ‰§è¡Œåˆ°e = next; e=null ã€‚æ­¤æ—¶çŠ¶æ€å¦‚å›¾2.5

å›¾2.5

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1627022574675-e21e668c-0598-4f7e-b2c9-0f872a5391a8.png)

çœ‹æœ€ç»ˆå›¾ç»“æœå¾—çŸ¥ï¼Œ**k1å’Œk2ä¹‹é—´å½¢æˆäº†ç›¸äº’çš„nextèŠ‚ç‚¹æŒ‡å‘ï¼Œå¯¼è‡´æ­»ç¯äº†**ã€‚è¿™ä¹Ÿæ˜¯1.7ç‰ˆæœ¬ä¸¥é‡çš„é—®é¢˜æ‰€åœ¨ã€‚



## 1.8ç‰ˆæœ¬åˆ†æ

### æ•°æ®ç»“æ„å®ç°

æ•°ç»„(åŸºæœ¬)+é“¾è¡¨(æ‰©å±•)+çº¢é»‘æ ‘(æ‰©å±•)

### å±æ€§

```
//é»˜è®¤hashè¡¨å®¹é‡å¤§å° 2^4=16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
//æœ€å¤§hashè¡¨å®¹é‡å¤§å°ï¼Œå¿…é¡»æ˜¯2çš„æ•´æ•°å¹‚
static final int MAXIMUM_CAPACITY = 1 << 30;
//é»˜è®¤åŠ è½½å› å­
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//é“¾è¡¨è½¬çº¢é»‘æ ‘é˜ˆå€¼
static final int TREEIFY_THRESHOLD = 8;
//çº¢é»‘æ ‘è½¬å›é“¾è¡¨é˜ˆå€¼
static final int UNTREEIFY_THRESHOLD = 6;
//é“¾è¡¨è½¬çº¢é»‘æ ‘æ—¶ï¼Œhashè¡¨å®¹é‡éœ€åˆ°è¾¾çš„æœ€å°å®¹é‡é˜ˆå€¼ï¼Œå¦åˆ™ä¼˜å…ˆæ‰©å®¹
static final int MIN_TREEIFY_CAPACITY = 64;
//è¡¨æœªè†¨èƒ€æ—¶å…±äº«çš„ç©ºè¡¨å®ä¾‹ã€‚1.8ç”¨å†…éƒ¨ç±»Nodeå®ç°
transient Node<K,V>[] table;
//å†…éƒ¨ç±»EntrySetå®ç°ï¼Œç”¨æ¥å­˜æ”¾ä¸é‡å¤keys
transient Set<Map.Entry<K,V>> entrySet;
//è¡¨ä¸­å­˜åœ¨çš„key-valueå¯¹å®ä¾‹æ•°é‡
transient int size;
//resizeçš„é˜ˆå€¼ (capacity * load factor)
int threshold;
//hashè¡¨çš„åŠ è½½å› å­
final float loadFactor;
//ä¿®æ”¹çš„æ¬¡æ•°ï¼Œæ›´å¤šåœ¨äºè¿­ä»£æ—¶ä½¿ç”¨ï¼Œ fail-fastæœºåˆ¶
transient int modCount;
```

### æ„é€ æ–¹æ³•

```
//åªç»™äº†é»˜è®¤çš„åŠ è½½å› å­
public HashMap() {
     this.loadFactor = DEFAULT_LOAD_FACTOR;  
 }
//åŸºæœ¬åŸºäºè¿™ä¸ªæ–¹æ³•ï¼Œå¦‚ï¼šHashMap()ï¼Œé»˜è®¤16ï¼Œ0.75f
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    //æœ€å¤§ä¹Ÿåªæœ‰2^30
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    this.loadFactor = loadFactor;
    //åˆå§‹åŒ–å®¹é‡ä¸”è®¾å®šé˜ˆå€¼
    this.threshold = tableSizeFor(initialCapacity);
}
//é€šè¿‡å¤šæ¬¡æŒ‰ä½å³ç§»ï¼Œæ¥è·å¾—ä¸€ä¸ª2çš„æ•´æ•°æ¬¡å¹‚
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

### é‡è¦æ–¹æ³•

#### put

```
public V put(K key, V value) {
    //å…ˆè®¡ç®—å¾—åˆ°hashå€¼
	return putVal(hash(key), key, value, false, true);
}
//é‡‡ç”¨ä½16ä½ä¸é«˜16ä½è¿›è¡Œå¼‚æˆ–å¤„ç†è·å–hashå€¼ï¼Œæ›´åŠ å¹³å‡åˆ†å¸ƒ
//å‚è€ƒï¼šhttps://blog.csdn.net/qq_42034205/article/details/90384772
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```

#### get

### å…¥é˜Ÿæ•°ç»„&æ‰©å®¹å®ç°
