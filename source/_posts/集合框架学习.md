---
title: 集合框架学习
date: 2021-07-16 22:43:18
tags: 
	- 集合
categories:
	- 集合
---

# HashMap

## 1.7版本分析

### 数据结构实现

数组(基本)+链表(扩展)

### 属性

```
//默认hash表容量大小 2^4=16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
//最大hash表容量大小，必须是2的整数幂
static final int MAXIMUM_CAPACITY = 1 << 30;
//默认加载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//表未膨胀时共享的空表实例。
static final Entry<?,?>[] EMPTY_TABLE = {};
//hash表resize，大小必须是2的整数幂
transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;
//表中存在的key-value对实例数量
transient int size;
//resize的阈值 (capacity * load factor)
int threshold;
//hash表的加载因子
final float loadFactor;
//修改的次数，更多在于迭代时使用， fail-fast机制
transient int modCount;
//map容量的默认阈值，高于该阈值的替代散列是用于字符串键。
//替代哈希降低了发生率由于字符串键的弱哈希码计算而导致的冲突。
static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;
//hash种子初始值
transient int hashSeed = 0;
```



### 构造方法

```
//基本基于这个方法，如：HashMap()，默认16，0.75f
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    //最大也只有2^30
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    this.loadFactor = loadFactor;
    //resize的阈值 就是给定的初始容量
    threshold = initialCapacity;
    //钩子方法
    init();
}
```



### 重要方法

#### put

```
public V put(K key, V value) {
    //判断是否没存放元素
    if (table == EMPTY_TABLE) {
        //初始化数组表，阈值，hash种子
        inflateTable(threshold);
    }
    if (key == null)
        //可存储key为null的，如果没存则会专门创建一个entry在bucket中且index为0.
        //有了则替换value
        return putForNullKey(value);
    //通过位运算(计算机底层运算，远比%速度快) 得到hash散列值
    int hash = hash(key);
    //通过hash值 与 表长度-1(底层方法) 进行与运算，控制下标一定会在长度范围内
    //如key='a'时，hash=103，length-1=15；0110 0111&0000 1111 = 0000 0111=7
    int i = indexFor(hash, table.length);
    //拿到当前数组下标位上的链表，没有则跳过，否则以它是否有下一节点来进行遍历
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        //先判断key是否一致，是则用新值替换旧值
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    //在此hash新增一个entry，底层createEntry方法，如果当前index处已经有了entry
    //那Entry<K,V> e = table[bucketIndex]; 会先拿到当前index的entry，即上一次添加的
    //table[bucketIndex] = new Entry<>(hash, key, value, e);再将上一次的entry设置为
    //新增的entry的next，且将新增的entry设置为当前index的首个元素(头插法)
    //(即每次新增的都会成为链表的第一个元素，位于数组下标处)
    addEntry(hash, key, value, i);
    return null;
}

private void inflateTable(int toSize) {
    // Find a power of 2 >= toSize 根据当前的阈值得到2的整数幂
    int capacity = roundUpToPowerOf2(toSize);
	//设置新的阈值 capacity * loadFactor
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    //设置新的容量大小
    table = new Entry[capacity];
    //初始化hash种子
    initHashSeedAsNeeded(capacity);
}

final int hash(Object k) {
    //初始值为0，put、扩容会计算有值
    int h = hashSeed;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
//获取当前容量下的hash 索引
static int indexFor(int h, int length) {
    return h & (length-1);
}
```

#### put流程图

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626853410085-148a0c47-6fbb-483c-abc6-3da2e5a022a0.png)



#### get

```
public V get(Object key) {
    //特殊的：key为null
    if (key == null)
        return getForNullKey();
    //
    Entry<K,V> entry = getEntry(key);

    return null == entry ? null : entry.getValue();
}

final Entry<K,V> getEntry(Object key) {
    if (size == 0) {
        return null;
    }
	//同样的先根据key得到hash值
    int hash = (key == null) ? 0 : hash(key);
    //再计算出index，去数组中对应的下标拿 entry数组遍历
    for (Entry<K,V> e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        //拿到相同hash值的 entry，没有则返回null
        if (e.hash == hash &&
            ((k = e.key) == key || (key != null && key.equals(k))))
            return e;
    }
    return null;
}
```

### 入队数组&扩容实现

上述put源码时，分析了当hash碰撞时，链表的插入为头部插入法，即**每次新增的key都是链表头节点**。

#### 扩容源码

```
void resize(int newCapacity) {
    //保存旧数组
    Entry[] oldTable = table;
    //保存旧容量
    int oldCapacity = oldTable.length;
    //作下容量判断处理，如果旧容量已经是最大了，则设置阈值为最大且直接返回
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
	//用新容量创建的新数组
    Entry[] newTable = new Entry[newCapacity];
    //initHashSeedAsNeeded 用新容量得到新的hash种子
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    //将新数组替换旧的数组
    table = newTable;
    //阈值设置为2*旧容量*0.75 与 最大取小
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}
//真正的从旧到新的转换
void transfer(Entry[] newTable, boolean rehash) {
    //2*旧容量
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        //遍历hash表中每个位置(下标)上的链表
        while(null != e) {
            //记录旧的next
            Entry<K,V> next = e.next;
            if (rehash) {
                //重新计算hash值
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            //根据上面计算的hash值 & 新容量 计算新hash桶中的下标位置
            int i = indexFor(e.hash, newCapacity);
            //头插法，所以需要将之前可能有的entry放到e的next去
            e.next = newTable[i];
            //将当前e放到hash表中i位置头部
            newTable[i] = e;
            //继续遍历
            e = next;
        }
    }
}
```

#### 单线程put&扩容图

假设：有一个长度为2的hash表，已有的数据如图1.1

扩容：继续put数据(k4,v4)，按hashmap的扩容(即旧容量*2)

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626940538262-9f6c0cf2-c2e0-4254-a3ff-3adb8306810f.png)

图1.1

扩容&转移数据到新table中

第一步转移k1：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626940720362-fa6456b3-9f83-4ad9-b62c-973104ccbc90.png)

第二步转移k2：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626940830940-55fe3cc4-dac3-43f6-a342-57c0569d01c3.png)

第三步转移k3：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626940983184-cda0313d-bf98-451c-8806-1c149fd5a77b.png)

第四步put：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626941978112-e27f7452-9ca9-4f58-a9c4-f649534e9417.png)

#### 多线程put&扩容图

场景：在图1.1的基础上，有两个线程**T1**和**T2**同时进行put，然后需要扩容的操作。

结合代码(主要就是while循环里)

```
while(null != e) {
    Entry<K,V> next = e.next;
    if (rehash) {
        e.hash = null == e.key ? 0 : hash(e.key);
    }
    int i = indexFor(e.hash, newCapacity);
    e.next = newTable[i];
    newTable[i] = e;
    e = next;
}
```

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626945465294-153d35d5-11ba-490c-8152-badaf511cfe8.png)



## 1.8版本分析

### 数据结构实现

数组(基本)+链表(扩展)+红黑树(扩展)

### 属性

### 构造方法

### 重要方法

#### put

#### get

### 入队数组&扩容实现
