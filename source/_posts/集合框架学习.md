---
title: 集合框架学习
date: 2021-07-16 22:43:18
tags: 
	- 集合
categories:
	- 集合
---

# HashMap

## 1.7版本分析

### 数据结构实现

数组(基本)+链表(扩展)

### 属性

```
//默认hash表容量大小 2^4=16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 
//最大hash表容量大小，必须是2的整数幂
static final int MAXIMUM_CAPACITY = 1 << 30;
//默认加载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//表未膨胀时共享的空表实例。
static final Entry<?,?>[] EMPTY_TABLE = {};
//hash表resize，大小必须是2的整数幂
transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;
//表中存在的key-value对实例数量
transient int size;
//resize的阈值 (capacity * load factor)
int threshold;
//hash表的加载因子
final float loadFactor;
//修改的次数，更多在于迭代时使用， fail-fast机制
transient int modCount;
//map容量的默认阈值，高于该阈值的替代散列是用于字符串键。
//替代哈希降低了发生率由于字符串键的弱哈希码计算而导致的冲突。
static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;
//hash种子初始值
transient int hashSeed = 0;
```



### 构造方法

```
//基本基于这个方法，如：HashMap()，默认16，0.75f
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    //最大也只有2^30
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    this.loadFactor = loadFactor;
    //resize的阈值 就是给定的初始容量
    threshold = initialCapacity;
    //钩子方法
    init();
}
```



### 重要方法

#### put

```
public V put(K key, V value) {
    //判断是否没存放元素
    if (table == EMPTY_TABLE) {
        //初始化数组表，阈值，hash种子
        inflateTable(threshold);
    }
    if (key == null)
        //可存储key为null的，如果没存则会专门创建一个entry在bucket中且index为0.
        //有了则替换value
        return putForNullKey(value);
    //通过位运算(计算机底层运算，远比%速度快) 得到hash散列值
    int hash = hash(key);
    //通过hash值 与 表长度-1(底层方法) 进行与运算，控制下标一定会在长度范围内
    //如key='a'时，hash=103，length-1=15；0110 0111&0000 1111 = 0000 0111=7
    int i = indexFor(hash, table.length);
    //拿到当前数组下标位上的链表，没有则跳过，否则以它是否有下一节点来进行遍历
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        //先判断key是否一致，是则用新值替换旧值
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    //在此hash新增一个entry，底层createEntry方法，如果当前index处已经有了entry
    //那Entry<K,V> e = table[bucketIndex]; 会先拿到当前index的entry，即上一次添加的
    //table[bucketIndex] = new Entry<>(hash, key, value, e);再将上一次的entry设置为
    //新增的entry的next，且将新增的entry设置为当前index的首个元素(头插法)
    //(即每次新增的都会成为链表的第一个元素，位于数组下标处)
    addEntry(hash, key, value, i);
    return null;
}

private void inflateTable(int toSize) {
    // Find a power of 2 >= toSize 根据当前的阈值得到2的整数幂
    int capacity = roundUpToPowerOf2(toSize);
	//设置新的阈值 capacity * loadFactor
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    //设置新的容量大小
    table = new Entry[capacity];
    //初始化hash种子
    initHashSeedAsNeeded(capacity);
}

final int hash(Object k) {
    //初始值为0，put、扩容会计算有值
    int h = hashSeed;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
//获取当前容量下的hash 索引
static int indexFor(int h, int length) {
    return h & (length-1);
}
```

#### put流程图

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1626853410085-148a0c47-6fbb-483c-abc6-3da2e5a022a0.png)



#### get

```
public V get(Object key) {
    //特殊的：key为null
    if (key == null)
        return getForNullKey();
    //
    Entry<K,V> entry = getEntry(key);

    return null == entry ? null : entry.getValue();
}

final Entry<K,V> getEntry(Object key) {
    if (size == 0) {
        return null;
    }
	//同样的先根据key得到hash值
    int hash = (key == null) ? 0 : hash(key);
    //再计算出index，去数组中对应的下标拿 entry数组遍历
    for (Entry<K,V> e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        //拿到相同hash值的 entry，没有则返回null
        if (e.hash == hash &&
            ((k = e.key) == key || (key != null && key.equals(k))))
            return e;
    }
    return null;
}
```



### 入队数组&扩容实现

上述put源码时，分析了当hash碰撞时，链表的插入为头部插入法，即**每次新增的key都是链表头节点**。

#### 扩容源码

```
void resize(int newCapacity) {
    //旧的
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }

    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable, initHashSeedAsNeeded(newCapacity));
    table = newTable;
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
}

void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}
```



## 1.8版本分析

### 数据结构实现

数组(基本)+链表(扩展)+红黑树(扩展)

### 属性

### 构造方法

### 重要方法

#### put

#### get

### 入队数组&扩容实现
