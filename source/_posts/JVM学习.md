#  JVM类加载

## JVM整体的加载过程

声明周期：

JVM伴随Java程序的开始而开始，程序的结束而停止。一个Java程序会开启一个JVM进程，一台计算机上可以运行多个程序，也就可以运行多个JVM进程。

JVM将线程分为两种：守护线程和普通线程。守护线程是JVM自己使用的线程，比如垃圾回收（GC）就是一个守护线程。普通线程一般是Java程序的线程，只要JVM中有普通线程在执行，那么JVM就不会停止。



启动大概过程：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1616934882154-8796864a-0a25-4773-83da-c87b0436e2b8.png)

launcher是一个static且new初始化的变量(即单例)

lancher构造方法会初始化ext类加载器、再由得到的ext类加载器去加载app类加载器。

（app类加载器父类是ext类加载器，ext类加载器原则上是引导类加载器，但引导类是c++创建的，所以其父类加载器为null）  

classLoader->即app类加载器，launcher源码体现。

ClassLoader:

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617460058137-9799f525-5b37-4498-947c-c2080670edcf.png)

## loadClass的类加载过程

**加载(load)>>链接(link)(验证****>>准备****>>解析)****>>初始化****(initialize)****>>使用****>**>卸载

- 加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的Main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
- 验证：校验字节码文件的正确性(语义合法、符合逻辑)、文件格式验证(需要符合class文件格式)、元数据验证、符号引用验证(确保解析能够正确执行)等。

- 准备：给类的**静态变量**分配内存，并赋予默认值(如：int的给0，boolean的给false)，final变量直接赋值。这个时候不包括实例变量，实例变量会在对象实例化的时候随着对象一块分配在Java堆中。
- 解析：将符号引用替换为直接引用(内存地址)，该阶段会把一些静态方法（符号引用，比如main()方法）替换为指向数据所存**内存的指针或句柄**等(直接引用)，这就是所谓的**静态链接**过程。**动态链接**是在程序运行期间完成的将符号引用替换为直接引用（每个类名、方法、包路径等都是一个符号 存在于常量池中，运行时加载到运行时常量池中javap xx.class -v 查看）。

- 初始化：对类的静态变量初始化为指定的值，执行静态代码块。 

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1616850631833-55a377a7-b126-40a1-a447-02cec032970e.png)

类被加载到方法区中后主要包含 **运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例**的引用等信息。

 

## 类加载器

- 引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等
- 扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包

- 应用程序类加载器：负责加载CLassPath路径下(项目路径)的类包，主要就是加载自己写的类
- 自定义加载器：负责加载用户自定义路径下的类包



## 双亲委派机制

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1616938423035-31c89842-622b-48db-a80a-20c763c35da5.png)

说明：JVM定义从应用程序类加载器开始加载(具体可看launcher源码 方法getClassLoader())，加载某个类时会委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器都无法在自己的加载类路径下找到目标类，则向下查找并载入目标类。

比如User类，先找到app类加载器加载，app类加载器先委托ext加载器加载，ext加载器再委托引导类加载器加载，引导类加载器在其类加载路径中找不到User类，则向下退回加载User类的请求，ext收到回复就自己加载，ext在其类加载路径中找不到User类，又向下退回给app类加载器，app类加载器则在自己的类加载路径里找User类，找到了则自己加载。95%以上都是app类加载器应用。(源码->appClassLoader的loadClass，跳到super的ClassLoader 的loadClas方法，重点->UrlClassLoader的findCass(name)，装载类即 defineClass() 去类路径拿到class文件)



为什么要设计双亲委派机制？

- 沙箱安全机制：自己的java.lang.String.class类不会被加载，防止核心API库被篡改。

根据双亲委派机制，先会向上加载一次，String类是引导类加载器加载的，这时候引导类加载器找到的是JDK自己的String类且返回(只会加载自己定义的类)，再向下回到app类中，这时候调用则会报错。

- 避免类的重复加载：向上委托，如果父加载器已经加载过了某个类，则会直接返回，子ClassLoader就不会再次加载一次，保证被加载类的唯一性。



## 全盘委托机制

全盘负责 指的是，当一个ClassLoader加载一个类时，除非显示的使用另外一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入。（如User类里用到了 Menu类，这时Menu的加载也是由User 的App类加载器加载）



## 自定义类加载器

初始化自定义类加载器，会先初始化父类加载器（默认是app类加载器），其中把自定义类加载器的父类设定为app类加载器，符合双亲委派机制。

1继承ClassLoader

2重写findClass方法

核心就是UrlClassLoader的loadClass()方法(实现双亲委派机制)和findClass()方法(装载类)。



## 打破双亲委派机制

不委托父加载器先加载了，在自定义加载器获得了直接返回。

重写loadClass方法   去掉双亲委派的逻辑



## Tomcat如何实现打破双亲委派机制

基于自定义的类加载器，是自定义类型的时，不委托父加载器加载。



# JVM内存模型

不同的机器对应的JVM处理机器码的方式都不同，如windows、mac系统

javap -c xx.class看汇编c

## 概念图

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617201607561-5faaec31-3353-4ed4-9c6e-5df99c95ae7e.png)

栈帧：一个方法对应一块栈帧区域，基本就是数据结构中的栈，特性先进后出，后进先出，符合代码执行特性。

操作数栈：临时的内存空间



验证代码：

```
package com.gx.demo.jvm;

public class MyMath {

    public int calculate(int a, int b){
        int result = 0;
        result = (a + b)*5;
        return result;
    }

    public static void main(String[] args) {
        MyMath myMath = new MyMath();
        int res = myMath.calculate(3, 7);
        System.out.println(res);
    }
}
```





## 字节码解析

javap -c MyMath.class

```
{
  public com.gx.demo.jvm.MyMath();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/gx/demo/jvm/MyMath;

  public int calculate(int, int);
    descriptor: (II)I
    flags: ACC_PUBLIC
    Code://一个方法对应一个栈帧，即有自己的局部变量表
      stack=2, locals=4, args_size=3//a->局部变量1 b->局部变量2
         0: iconst_0//将int类型常量0压入栈 常量0
         1: istore_3// 将int类型值存入局部变量3 参数result
         2: iload_1//从局部变量1中装载int类型值 参数a
         3: iload_2//从局部变量2中装载int类型值 参数b
         4: iadd//执行int类型的加法
         5: iconst_5//将int类型常量5压入栈 得到a+b=5
         6: imul//乘法
         7: istore_3// 将int类型值存入局部变量3 即5*10=50
         8: iload_3//从局部变量2中装载int类型值 50
         9: ireturn//返回
      LineNumberTable:
        line 6: 0
        line 7: 2
        line 8: 8
      LocalVariableTable://局部变量
        Start  Length  Slot  Name   Signature
            0      10     0  this   Lcom/gx/demo/jvm/MyMath;
            0      10     1     a   I
            0      10     2     b   I
            2       8     3 result   I

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=3, args_size=1
         0: new           #2                  // class com/gx/demo/jvm/MyMath
         3: dup//复制栈顶部一个字长内容
         4: invokespecial #3                  // Method "<init>":()V
         7: astore_1//将引用类型或returnAddress类型值存入局部变量1 参数new的myMath，存的堆地址
         8: aload_1//从局部变量1中装载引用类型值
         9: iconst_3//将int类型常量3压入栈
        10: bipush        7   //将一个8位带符号整数压入栈 7 也占一次操作(11)
          //iconst_5 = 8 (0x8)指令码
          //bipush = 16 (0x10)指令码
        12: invokevirtual #4  //调度对象的方法   // Method calculate:(II)I
        15: istore_2//将int类型值存入局部变量2 参数res
        16: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;
        19: iload_2//从局部变量2中装载int类型值 calculate返回的结果50
        20: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V
        23: return
      LineNumberTable:
        line 12: 0
        line 13: 8
        line 14: 16
        line 15: 23
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      24     0  args   [Ljava/lang/String;
            8      16     1 myMath   Lcom/gx/demo/jvm/MyMath;
           16       8     2   res   I
}
```

此处涉及一个常量推送到栈顶中，不同范围指令不同：

iconst_*  即-1-5 

bipush    即**-128~127** 

sipush    即-32768~32767 

ldc         即**-2147483648~2147483647**

具体可见官网：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iconst_i

icons-》push int constant

bipush-》push byte , etc.

| 指令名称    | 指令码（对应class码文件） | 数值 |
| ----------- | ------------------------- | ---- |
| *iconst_m1* | 2 (0x2)                   | -1   |
| *iconst_0*  | 3 (0x3)                   | 0    |
| *iconst_1*  | 4 (0x4)                   | 1    |
| *iconst_2*  | 5 (0x5)                   | 2    |
| *iconst_3*  | 6 (0x6)                   | 3    |
| *iconst_4*  | 7 (0x7)                   | 4    |
| *iconst_5*  | 8 (0x8)                   | 5    |

简单说下calculate方法 运作情况：

1、局部变量和操作数栈各自对应

--》0: iconst_0，0代表程序计数器的位置，每次操作完都会更新

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617203787171-c03c0e63-0f00-4afc-bdeb-9c7cd7408ab5.png)



2、由字节码执行引擎执行操作数为1的步骤,且更新操作数(由字节码执行引擎修改)

--》1: istore_3 程序计数器=1

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617204051112-2efad6e6-54b5-4376-ad5e-7bebf807b85c.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617203827373-5158c452-ea47-405b-b62d-e4090f98a6c4.png)

3a+b操作

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617204170110-790f84ca-85f2-4e2c-bd35-07841e87b88a.png)

说明：3、7、5等常量都放在操作数栈，临时内存

动态链接：myMath.calculate()，要去解析 找到对应的方法

局部变量和堆：new  MyMath()

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617204681301-ed1af7be-6487-445a-b0ee-271077c47d4f.png)

## 栈

### Java虚拟机栈

Java虚拟机栈是线程私有的，就是平常说的堆栈中的“栈内存”。此处指的是JVM中的运行时内存区域的概念划分，而不是JMM(java 内存模型)，每个方法在执行的同时都会创建一个栈帧(Stack Frame)，方法结束，栈内存也就自动释放了。

其中包括四个部分，分别是：

1局部变量表(用来存储局部变量表的，包含两部分：一是方法中的参数，二是方法中创建的局部变量。局部变量必须被初始化才能使用。包括this，FILO)

2操作数栈(方法用到的常量等，FILO)

3动态链接(方法中对象的引用，存的堆地址等)

4方法出口(方法return到哪个地方)等信息

### 本地方法栈

JVM 调用本地方法(Native)接口时使用，也是线程私有的(历史原因，之前很多接口由C/C++实现的，字节码解析后调用相应的dll文件)，这时候使用的空间就是本地方法栈。

## 程序计数器

在JVM中的运行时内存区域的概念划分中，目前自己了解到主要以下作用，其通过字节码执行引擎工作执行class文件，由字节码执行引擎修改当前这个程序计数器的值来选取下一条需要执行的字节码指令(上面图中有体现)。

(以下为参考)

分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。



JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。



当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址；如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。



程序计数器占用的内存空间很少，也是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域

## 堆

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617499842167-f422f185-98b9-4655-873e-c3740aa9331b.png)

堆内存是**所有线程共享**的，基本上可以分为**一个年轻代**和**一个老年代**。



**1.年轻代**分为两部分：伊甸区（Eden space）和 幸存者区（Survivor space）。所有的类都是在伊甸区被new出来

的。幸存者区又分为 From 区 和 To 区。当Eden区的空间用完时，程序要继续new对象，JVM的垃圾回收器将对

Eden区进行垃圾回收（Minor GC，通过gc root(从栈(局部变量)、方法区中去找变量的引用，一直往前找，找到根时如果没有别人对象引用，则会标志为垃圾对象，否则标志为非垃圾对象)），将Eden区中的不再被其他对象应用的对象销毁，然后将剩余的对象移到From Survivor区。若From区也满了，再对该区进行垃圾回收，然后将剩余的移动到To Survivor区。



**2.老年代**：新生代经过多次GC仍然存活的对象移动到老年代。若老年代满了，则会发生Major GC（Full GC）进行老年区的清理。若老年区经理了清理后依然无法进行对象的保存，则会抛出OOM异常以及STW事件。

Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。



**3.元空间**：在JDK1.8以后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用的本地内存。而永久代在虚拟机中，永久代逻辑结构上也属于堆，但是物理上不属于。



## 方法区

方法区也是所有线程所共享的。它用于存储已经被JVM加载的类信息(类型信息：差不多是C的对象元信息)、常量(存堆中的地址)、静态变量、即时编译器(JIT)编译后的代码等数据信息。且设有保护程序，当一个线程正在访问的时候，另一个线程不能同时加载一个类，需要延迟等待。

同时，方法区中的大小是可以改变的，运行时也可以扩展，对象也可进行垃圾回收，不过条件比较苛刻，需要没有任何引用才会进行回收。

JDK8之前是永久代，之后叫元空间。



# JVM内存参数设置

## 堆

常用：

-Xms：JVM初始分配的内存由-Xms指定，默认是物理内存的1/64

 -Xmx：JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4

新生代： 

-Xmn

-Xmn2G：设置年轻代大小为2G。

## 方法区

-XX:MetaspaceSize 默认21MB(64位JVM)，达到该值则会进行full gc进行类型加载，同时收集器对值进行调整。

-XX:MaxMetaspaceSize 默认无限(64位JVM)，即只限制于本地内存大小

## 栈

-Xss 默认1M，该值设置的越小，说明一个线程栈里面能分配的栈帧就越少，但是对JVM整体来说能开启的线程数就越多。



# JVM对象创建与内存分配机制

## 对象创建

大概流程：

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/705191/1618323519375-4fba8feb-6f5a-4522-bab1-6e1947a1ae25.jpeg)

### 1类加载检查

虚拟机遇到一个new命令时(new指令在语言层次上，代表new关键字，对象的克隆或者序列化等)，

首先将要检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过(即类加载那五个步骤)。如果没有就必须先执行类加载过程。



那什么情况下需要去加载类呢？

1、当创建对象和使用到静态变量的时候，即遇到new、getstatic、putstatic或者invokestatic指令的时候(读取或者设置一个静态变量，finnal修饰和已加载的静态字段除外)。

下图是上面字节码解析中涉及到的一个static变量：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617761637319-ed84cc95-32cc-4fb1-88fc-586efc23222b.png)

2、当一个类被初始化时，如果其有父类，且没被初始化过，那会先触发父类的初始化。

3、当使用java.lang.reflect(即反射)时，如果对象没被初始化，则会先进行初始化。

4、当JVM启动时，会先执行一个指定的方法(public main())，这个类会被先初始化。



### 2分配内存

在类加载成功后，虚拟机就需要为新生对象分配内存了。

Java的堆内存是被所有线程所共享的一块内存区域，其主要用于存放对象的实例(也包括数组实例)，为实例对象分配内存就是指在堆内存中分配一块大小确定的内存**划分出来**，并给到对象。

其实现主要通过两个方法：

1.指针碰撞法

假设JAVA堆中的内存是绝对规整的，所有用过的内存都放在一侧，空闲的内存放在另一侧，中间通过一个指针作为分界点，**当需要分配内存时，仅仅需要将那个指针往空闲侧移动与对象大小相等的距离即可**。

使用的GC收集器：Serial、ParNew，适用堆内存规整（即没有内存碎片）的情况下。

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617764446559-8103c54a-1e23-4547-a1e4-09dd12c3916c.png)

(蓝色代表已分配内存空间，白色代表没分配的内存空间)

**在最后一块已分配内存后有一个指针连接空闲内存区域。**



2.空闲列表法

假设JAVA堆中的内存不是规整的，已经使用过的内存空间是相互交错的，那此时就不能使用指针碰撞来进行内存分配了。**JVM通过维护一个列表，来记录可用的内存信息，在分配的时候从列表中找到一块足够大的空间来划分给对象实例，并更新列表上的记录**。

使用的GC收集器：CMS，适用堆内存不规整的情况下。

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617764987257-a0494da5-c83c-4092-b0b3-9e4635206088.png)

(蓝色代表已分配内存空间，白色代表没分配的内存空间)



问题：划分内存不管是指针碰撞法，抑或是空闲列表法，当一个线程开始准备占用内存时，另一个线程也可能在抢占内存，这时候即会引起一个熟知的问题-->并发？

解决：如何解决并发来保证线程安全，一般是两种方法

1.CAS(compare and swap)比较替换

CAS是**乐观锁**的一种实现方式。即每次不去加锁，而是假设不会发生冲突的来完成某个操作，如果发生冲突失败就重试，直到操作成功为止。JVM采用CAS配上失败重试的方式保证更新操作的原子性，来对分配内存的动作进行同步处理。

2.TLAB(Thread Local Allocation Buffer) 本地线程分配缓冲

**按照线程****在不同的空间之中进行内存的划分操作**。即给每一个线程在Java堆内存中预先划分、分配一小块内存。也就是说首先在TLAB中配内存，当对象实例需要的内存**大于TLAB的剩余内存**，或者**TLAB中的内存消耗殆尽**的时候，使用CAS机制进行内存的分配。

参数设置：-XX:+UseTLAB（JVM默认开启），关闭-XX:-UseTLAB



### 3初始化零值

在分配内存后， JVM需要将分配到的内存空间都初始化为零值(不包括对象头)，如果使用TLAB，这一过程也可以提前至TLAB分配内存时安进行。这一步操作保证了对象的实例字段在Java代码中可以步赋初始值就能直接使用，程序能够访问到这些字段的数据类型所对应的零值(如int的0，boolean的false)。



### 4设置对象头

在初始化零值后，JVM需要对对象进行必要的设置，比如：某一个对象属于哪个类的实例，如何才能够找到该类的元数据信息，该对象的hash码、GC分代年龄等信息。以上这些信息基本存在与对象头(Object Header)之中。

（锁相关：**Java对象头和monitor是实现synchronized的基础**）

在HotSpot，对象在内存中存储的布局可以分为3个区域：

1对象头（Header）

2实例数据（Instance Date）

3对齐填充（Padding）

**对象头**由Mark Word(标记字段)和Kclass pointer(类型指针)组成。

Mark Word：(32位占4字节，64位占8字节)用于存储对象自身的运行时数据，如哈希码(Hash Code)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。(**对象和数组稍有差别，数组长度占4字节**)。

Kclass pointer：(开启指针压缩占4字节，不开启占8字节)指对象指向它的类元数据的指针，JVM通过这个指针来确定这个对象是哪个类的实例。

下图是内存布局大概分布：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617776742667-43bdf030-6f55-4d31-917b-2351afc45884.png)

下图是32位虚拟机对象头各锁对应的信息；

对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit）），它是实现轻量级锁和

偏向锁的关键。

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617776860916-57982473-5348-4a77-a956-e02d2d836f0a.png)

下图是结合栈以及方法区画了一个个人理解和参考的图

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617779390080-711e6daa-1ace-47c6-a047-c46e389b92ad.png)



### 5执行init方法

执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值(注意，这与上面的赋零值不同，这是由程序员赋的值)，和执行构造方法。



### 指针压缩和对象大小

启用指针压缩:­XX:+UseCompressedOops(默认开启)，禁止指针压缩:­XX:­-UseCompressedOops

大概理解：

在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力。

为了减少64位平台下内存的消耗，启用指针压缩功能。													

​																																												

## 对象内存分配

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/705191/1618323519502-c4b0f3af-2faa-452b-8288-5add52720d2a.jpeg)

### 1在栈上面为对象分配内存

在Java中，对象的实例几乎都在堆上分配内存，**当对象没有被引用的时候**，需要依赖GC进行垃圾回收，释放内存。如果对象实例过多，会给GC带来巨大的压力，也会影响应用程序的性能。

为了减少**临时对象**在堆内分配的数量，JVM通过逃逸分析确定该对象**不会被外部访问**。如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的内存空间就可以**随栈帧出栈而销毁**，就减轻了垃圾回收的压力。 

对象逃逸分析：就是分析**对象动态作用域**，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中(此时则需要分配堆内存)。



举例：

```
    public MyMath getMath(){
        MyMath res = new MyMath();
        //xxx
        return res;
    }

    public void getMath2(){
        MyMath res = new MyMath();
        //xxx
    }
```

像getMath方法，很显然其需要返回一个对象，可能是被另一个调用方使用或者返回等，因此它的作用域不确定。

但getMath2方法，当方法一结束，res对象即无效了，因此对于这种对象，可以将其放在栈中，让它与方法一起结束，跟随栈内存一起被回收。

开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过**标量替换**优先分配在栈上(栈上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis) 

**(在****栈上面分配内存依赖于逃逸分析和标量替换，需要同时开启**)

**标量替换**：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该 对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就 不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。 

**标量与聚合量**：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及 reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。



### 2在堆上面为对象分配内存

上面介绍堆时已提到过，堆上分配内存大概情况：

所有的类都是在伊甸区被new出来的。幸存者区又分为 From 区 和 To 区。当Eden区的空间用完时，程序要继续new对象，JVM的垃圾回收器将对Eden区进行垃圾回收（Minor GC），将Eden区中的不再被其他对象应用的对象销毁，然后将剩余存活的对象移到From Survivor区。若From区也满了，再对该去、区进行垃圾回收，然后将剩余的移动到To Survivor区。最终再继续存活下来的将存放到老年代。



#### 2.1Eden区分配

**Eden与Survivor区默认8:1:1**

**-XX:+SurvivorRatio 设置新生代内存的占比**

堆新生代：包括Eden区域和Survivor区域(**默认是8**)

参数假设配置N，配置N表示伊甸园区Eden大小即是幸存区from的N倍，也是幸存区to的N倍。

eden:s0:s1=N:1:1

Xmn/(N+1+1) 就是每一份的大小，对应乘就是Eden，s0,s1的大小

即Eden=N*(Xmn/(N+2))，survivor(from)=suvivor(to)=1*(Xmn/(N+2))



因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，**让eden区尽量的大，survivor区够用即可，** 

JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy 



**两种情况的GC：**

- **Minor GC/Young GC**：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。 
- **Major GC/Full GC**：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。 

可通过-XX:+PrintGCDetails进行GC的查看



#### 2.2大对象直接进入老年代 

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节)

-XX:+UseSerialGC 。

为什么要这样呢？ 

为了避免为大对象分配内存时的复制操作而降低效率。



#### 2.3长期存活的对象将进入老年代

虚拟机给每个对象一个对象年龄（Age）计数器。 

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 



#### 2.4对象动态年龄判断 

当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的 50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了， 例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发的。 



#### 2.5老年代空间分配担保机制

在发生Minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。

1如果大于，则此次Minor GC是安全的，直接进行Minor GC即可。

2如果小于，则会检查-XX:-HandlePromotionFailure

2.1如果没有设置，则会进行Full GC(给老年代和年轻代一起清理一次)

2.2如果有设置，则会判断老年代剩余空间大小是否 **小于** 历史**每一次Minor GC**后进入老年代的对象的**平均大**

**小**，如果**不小于则发生Minor GC，如果小于，则会发生Full GC(对老年代和年轻代一起发生一次垃圾回收)。**

如果回收完还是没有足够空间存放新的对象就会发生"OOM" 

当然，**如果****Minor** **gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full    gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”**



## 对象内存回收



### 一般回收方法

都知道内存回收的是无用对象，但是怎么判断对象是无用还是有用呢？

比较容易想到的是引用计数法。那么什么是引用计数法呢？



**引用计数法**：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加１;当引用失效时，计数器值就减１;任何时刻计数器为０的对象就是不可能再使用的。

虽然引用计数算法实现简单且判断效率高效，但是在主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象间相互循环引用的问题。



既然我们学习的是Java虚拟机相关的内容，那我们就要了解Java虚拟机的实现中是怎么判断对象是否存活的？



**可达性分析算法**：在主流的商用程序语言的主流实现中，都是称通过可达性分析来判断对象是否存活的。这个算法的基本思路就是通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链,当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

如图所示：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1617876354993-d468469f-be00-47fb-875c-1243dca5a25d.png)



​			



### 常用引用类型

在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象

- 方法区中常量引用的对象
- 本地方法栈中JNI(即一般说的Native方法)引用的对象

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判断对象是否存活都与"引用"有关。



在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)４种,这4种引用强度依次逐渐减弱。



**强引用**就是指在程序代码之中普遍存在的，类似"Object obj=new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。



**软引用**是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。



**弱引用**也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。



**虚引用**也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。



### 最后的救赎(判断是否存活)

对象是怎么被杀死的?

在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历**两次标记**过程——如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象**是否有必要执行finalize()方法**。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。(那么问题来了，这种情况下的二次标记在哪里？)



如果这个对象被判定为**有必要执行**finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的"执行"是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环,将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。**finalize()方法是对象逃脱死亡命运的最后一次机会**，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中成功拯救自己——**只要重新与引用链上的任何一个对象建立关联**即可，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出"即将回收"的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。



### 如何判断一个类是无用的类

方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢? 类需要同时满足下面3个条件才能算是 “无用的类” :

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。

- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

​															

# JVM字节码文件结构剖析

javap -verbose xxx.class 反编译

**通过16进制查看器打开的文件结构是一个当个字节来显示，因为一个16进制数可** 

**以通过4位来表示,一个字节8位可以表示二个16进制数**



具体代码见目录 --> 字节码解析



整体结构分为：

- class文件结构
- 类的访问权限

- 字段表结构
- 方法表结构

- 方法中属性表结构



# JVM垃圾收集器

## 基本回收算法

在堆中几乎保存着所有能够想到的对象实例，也就是根据对象存活的周期不同，将内存分为不同的块。

而目前的JVM中处理垃圾收集的方式--几乎都采用的分代收集算法(**即****将对象熬过垃圾收集的次数，视为对象的年龄，也依此将对象至少划分为新生代和老年代这两个代**)。



### 标记-清除算法

**简介**：最基础的收集算法是“标记-清除”(Mark-Sweep)算法，如其名，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；也可以返回来标记存活的对象，统一回收没有被标记的对象。后续算法都是基于这个优化改进的。

**缺点**：

- 效率问题：如果需要标记的对象太多，或者清除的对象太多，效率都不高
- 空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后分配较大对象时，无法找到足够的连续的内存而不得不提前触发另一次垃圾收集操作。

回收前：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618585640205-90fc287c-78b1-421f-aea1-e26fce4618d2.png)

回收后：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618585655862-ec2a60f7-0682-489c-ba84-8fabb994dbd9.png)



### 标记-复制算法

简介：为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，运行高效。

缺点：

- 直接将原有内存缩小为了原来的一半，代价太高了。
- 如果对象存活率较高时就要进行较多的复制操作，效率将会变低。



回收前：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618586701469-a04cd7c8-ae65-4eef-81bc-a5b6575593cf.png)

回收后：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618586749624-2d752b7e-e519-4652-8e26-ae07d4d2235f.png)



### 标记-整理算法

复制算法缺点就是**对象存活率较高**时，进行的复制操作多，效率低下，更关键的时浪费的50%的内存空间。如果不想浪费，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般不能直接选择复制算法。

**根据老年代的特点(对象存活率高，难于GC)**，出现了“标记-整理”算法。标记过程仍然与“标记-清除”算法一样，但后续步骤中不再直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

回收前：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618624988169-70edd65b-ee72-46f7-b3d3-b5f694f3fde6.png)

回收后：

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618625050340-f97c4be5-454a-4f86-bb91-6c528c7235ee.png)

### 分代收集算法

**在新生代中**，每次垃圾回收都会有大批对象死去，只有少数存活，那就选用复制算法，只要付出少量存活对象的复制成本就可以完成收集。

**而老年代**中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。



### HotSpot算法实现

众所周知，一般回收内存方法包括计数法、可达性分析法。可达性分析法即GC ROOTS(枚举根结点，找到引用链)。

以此为例，1.枚举的节点主要存在于全局性的引用(如常量)与执行上下文(如栈帧的局部变量表)中，目前很多应用仅方法区就有数百兆，如果逐一检查，必定消耗很多时间。2.另可达性分析对执行时间也很敏感，这就体现在GC的停顿上，因为分析工作必须在一个时间点上，不可以出现分析过程中，对象的引用关系还会发生变化的情况，不然无法保证准确性。这也是导致GC时**必须停顿所有Java执行线程(STOP THE WORLD)**的一个重要原因。



随即引出**安全点**的概念：

在HotSpot中，当执行系统停顿下来后，其会使用一组成为OopMap的数据结构来记录对象的引用，保存对象内什么偏移量上是什么类型的数据，以及**特定位置记录下栈和寄存器中有哪些位置是引用**。这样在GC扫描时，就能直接得知相关信息了。

在OopMap的协助下，HotSpot可以快速准确地完成GC ROOTS枚举，但随着引用关系变化，或者OopMap内容变化的指令太多，如果为每一条指令都生成OopMap指令，那就会需要大量的额外空间。

所以HotSpot也不可能为每条指令都生成OopMap。只有在**特定的位置**才会记录下栈、寄存器信息，这些位置称为**“安全点”(SafePoint)**，即程序执行时并非在所有地方都停顿下来进行GC，只在安全点停顿。

**SafePoint的选定既不能太少以至于让GC等待时间太长，也不能太多导致GC过于频繁，加大运行时的负荷。**

所以，安全点的选择基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的--因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长就过长时间运行。“长时间执行”的最明显的特征就是指令序列复用，例如：方法调用、循环跳转、异常跳转等。



## 垃圾收集器种类

**HostSpot虚拟机中的垃圾收集器**

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618627307192-d8bdd439-baab-4226-b948-0cbfb82ee031.png)

注：两个收集器之间存在连线，说明其可以搭配使用。特殊说明：CMS备选老年代收集器可以使用Serial Old。



### Serial收集器

**-XX:+UseSerialGC** 

简介：Serial收集器是最基本、发展历史最悠久的垃圾收集器，曾是虚拟机新生代收集的唯一选择。

Serial串行的、连续的，很明显其代表的是一个单线程收集器。但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或者一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾回收的时候，必须**暂停其所有的**工作线程(STW)，直到它收集结束。



工作运行图：Serial组合Serial Old

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618635052800-2ccf3c53-e825-45d1-9025-693b5bd2eb57.png)

注：**新生代、老年代都是单线程**

**缺点**：Stop The World给用户带来的不良体验，为消除或者减少工作线程因为内存回收而导致停顿的努力一直进行着，所以有了后续的垃圾收集器的出现，但是仍然没办法完全消除。

**优点**：与其它单线程收集器相比，其简单而高效。因为Serial没有线程交互的开销，自然可以拥有高效的单线程收集效率。



### Serial Old收集器

**-XX:+UseSerialOldGC**

简介：如一开始的收集器连接图，Serial Old收集器是Serial新生代收集器的老年代版本，它同样是一个单线程的收集器，使用的是“标记-整理”算法。其主要意义是给Client模式下的虚拟机使用。

如果在Server 模式下，它有两大用途：

- 在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用
- 作为CMS收集器的后备预案



工作图与Serial收集器一致。



### ParNew收集器

简介：ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，还包括Serial收集器的控制参数

**-XX:+UseParNewGC**

**-XX:+SurvivorRatio 设置新生代内存的占比**

**-XX:PretenureSizeThreshold 可直接进入老年代对象大小**

**-XX:HandlePromotionFailure 老年代空间担保机制开启**

**以及收集算法，STW，对象分配规则、回收策略等都与Serial收集器其完全一致。**



它是运行在Server模式下的新生代收集器的首选，除了Serial收集器之外，目前只有它能够和CMS收集器配合工作



工作运行图：ParNew 组合 Serial Old

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618635237451-8b1e0ea9-0650-4099-a5bd-11a4df1a6b9f.png)

注：**新生代多线程，老年代单线程**



### Parallel Scavenge收集器

简介：Parallel Scavenge收集器是一个新生代的收集器，也是使用复制算法的收集器，又是并行的多线程收集器。

其特点是它的关注点与其它收集器不同，CMS等收集器是尽可能地**缩短垃圾收时用户线程的停顿时间**，而Parallel Scavenge的目标则是达到一个可以控制的吞吐量(Throughput)。

**所谓吞吐量就是CUP用于运行代码的时间与CPU总耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)。**

Parallel Scavenge提供了多个参数用于找到合适的吞吐量或停顿时间。

**-XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间ms**

**-XX:GCTimeRatio 设置吞吐量大小(垃圾收集时间大小)(0-100的整数，默认99) 假设此参数设置为19，那允许的最大GC时间就占总时间的5%(即 1/（1+19）)**



### Parallel Old

Parallel Old是Parallel Scavenge的老年代版本，使用多线程和“标记-整理”算法。JDK1.6所提供。一般以吞吐量以及CPU为资源敏感的场合下，都可以优先考虑Parallel Scavenge加Parallel Old的组合。



工作运行图：Parallel Scavenge 组合 Parallel Old

![img](https://cdn.nlark.com/yuque/0/2021/png/705191/1618636773174-beb16e4e-3401-4874-be0c-f37c4524d98a.png)

注：**新生代、老年代都是多线程运行GC**



### CMS收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。

从名字(“Mark Sweep”)可以看出，CMS收集器是**基于“标记-清除”算法**实现的。

整个过程包括四个步骤：

- 初始标记(initial mark):需要暂停所有线程(STW)，标记以下GC ROOTS能直接关联到的对象，速度很快。
- 并发标记(concurrent mark):指的是从GC ROOTS的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是**不需要STW**，可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会导致已经标记过的对象发生改变。

- 重新标记(remark):需要暂停所有线程(STW)。指的是为了**修正**并发标记期间**因为用户程序继续运行**而导致标记**产生变动**的那一部分对象的标记记录，而且这个停顿时间一般会比初始标记的时间稍长，远远比并发标记的时间短。(三色标记)
- 并发清除(concurrent sweep):开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理。(三色标记)

- 并发重置(reset):重置本次GC过程中的标记数据。





# JVM调优工具及了解



## 常见的调优指令



### jps



### jstack



### jvisualvm